import {
  require_react
} from "./chunk-ZOIWZPCO.js";
import {
  __commonJS
} from "./chunk-DFKQJ226.js";

// node_modules/invariant/browser.js
var require_browser = __commonJS({
  "node_modules/invariant/browser.js"(exports, module) {
    "use strict";
    var invariant = function(condition, format, a, b, c, d, e, f) {
      if (true) {
        if (format === void 0) {
          throw new Error("invariant requires an error message argument");
        }
      }
      if (!condition) {
        var error;
        if (format === void 0) {
          error = new Error(
            "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
          );
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(
            format.replace(/%s/g, function() {
              return args[argIndex++];
            })
          );
          error.name = "Invariant Violation";
        }
        error.framesToPop = 1;
        throw error;
      }
    };
    module.exports = invariant;
  }
});

// node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/prop-types/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/prop-types/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/bit-twiddle/twiddle.js
var require_twiddle = __commonJS({
  "node_modules/bit-twiddle/twiddle.js"(exports) {
    "use strict";
    "use restrict";
    var INT_BITS = 32;
    exports.INT_BITS = INT_BITS;
    exports.INT_MAX = 2147483647;
    exports.INT_MIN = -1 << INT_BITS - 1;
    exports.sign = function(v) {
      return (v > 0) - (v < 0);
    };
    exports.abs = function(v) {
      var mask = v >> INT_BITS - 1;
      return (v ^ mask) - mask;
    };
    exports.min = function(x, y) {
      return y ^ (x ^ y) & -(x < y);
    };
    exports.max = function(x, y) {
      return x ^ (x ^ y) & -(x < y);
    };
    exports.isPow2 = function(v) {
      return !(v & v - 1) && !!v;
    };
    exports.log2 = function(v) {
      var r, shift;
      r = (v > 65535) << 4;
      v >>>= r;
      shift = (v > 255) << 3;
      v >>>= shift;
      r |= shift;
      shift = (v > 15) << 2;
      v >>>= shift;
      r |= shift;
      shift = (v > 3) << 1;
      v >>>= shift;
      r |= shift;
      return r | v >> 1;
    };
    exports.log10 = function(v) {
      return v >= 1e9 ? 9 : v >= 1e8 ? 8 : v >= 1e7 ? 7 : v >= 1e6 ? 6 : v >= 1e5 ? 5 : v >= 1e4 ? 4 : v >= 1e3 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
    };
    exports.popCount = function(v) {
      v = v - (v >>> 1 & 1431655765);
      v = (v & 858993459) + (v >>> 2 & 858993459);
      return (v + (v >>> 4) & 252645135) * 16843009 >>> 24;
    };
    function countTrailingZeros(v) {
      var c = 32;
      v &= -v;
      if (v)
        c--;
      if (v & 65535)
        c -= 16;
      if (v & 16711935)
        c -= 8;
      if (v & 252645135)
        c -= 4;
      if (v & 858993459)
        c -= 2;
      if (v & 1431655765)
        c -= 1;
      return c;
    }
    exports.countTrailingZeros = countTrailingZeros;
    exports.nextPow2 = function(v) {
      v += v === 0;
      --v;
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v + 1;
    };
    exports.prevPow2 = function(v) {
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v - (v >>> 1);
    };
    exports.parity = function(v) {
      v ^= v >>> 16;
      v ^= v >>> 8;
      v ^= v >>> 4;
      v &= 15;
      return 27030 >>> v & 1;
    };
    var REVERSE_TABLE = new Array(256);
    (function(tab) {
      for (var i = 0; i < 256; ++i) {
        var v = i, r = i, s = 7;
        for (v >>>= 1; v; v >>>= 1) {
          r <<= 1;
          r |= v & 1;
          --s;
        }
        tab[i] = r << s & 255;
      }
    })(REVERSE_TABLE);
    exports.reverse = function(v) {
      return REVERSE_TABLE[v & 255] << 24 | REVERSE_TABLE[v >>> 8 & 255] << 16 | REVERSE_TABLE[v >>> 16 & 255] << 8 | REVERSE_TABLE[v >>> 24 & 255];
    };
    exports.interleave2 = function(x, y) {
      x &= 65535;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y &= 65535;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    };
    exports.deinterleave2 = function(v, n) {
      v = v >>> n & 1431655765;
      v = (v | v >>> 1) & 858993459;
      v = (v | v >>> 2) & 252645135;
      v = (v | v >>> 4) & 16711935;
      v = (v | v >>> 16) & 65535;
      return v << 16 >> 16;
    };
    exports.interleave3 = function(x, y, z) {
      x &= 1023;
      x = (x | x << 16) & 4278190335;
      x = (x | x << 8) & 251719695;
      x = (x | x << 4) & 3272356035;
      x = (x | x << 2) & 1227133513;
      y &= 1023;
      y = (y | y << 16) & 4278190335;
      y = (y | y << 8) & 251719695;
      y = (y | y << 4) & 3272356035;
      y = (y | y << 2) & 1227133513;
      x |= y << 1;
      z &= 1023;
      z = (z | z << 16) & 4278190335;
      z = (z | z << 8) & 251719695;
      z = (z | z << 4) & 3272356035;
      z = (z | z << 2) & 1227133513;
      return x | z << 2;
    };
    exports.deinterleave3 = function(v, n) {
      v = v >>> n & 1227133513;
      v = (v | v >>> 2) & 3272356035;
      v = (v | v >>> 4) & 251719695;
      v = (v | v >>> 8) & 4278190335;
      v = (v | v >>> 16) & 1023;
      return v << 22 >> 22;
    };
    exports.nextCombination = function(v) {
      var t = v | v - 1;
      return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
    };
  }
});

// node_modules/dup/dup.js
var require_dup = __commonJS({
  "node_modules/dup/dup.js"(exports, module) {
    "use strict";
    function dupe_array(count, value, i) {
      var c = count[i] | 0;
      if (c <= 0) {
        return [];
      }
      var result = new Array(c), j;
      if (i === count.length - 1) {
        for (j = 0; j < c; ++j) {
          result[j] = value;
        }
      } else {
        for (j = 0; j < c; ++j) {
          result[j] = dupe_array(count, value, i + 1);
        }
      }
      return result;
    }
    function dupe_number(count, value) {
      var result, i;
      result = new Array(count);
      for (i = 0; i < count; ++i) {
        result[i] = value;
      }
      return result;
    }
    function dupe(count, value) {
      if (typeof value === "undefined") {
        value = 0;
      }
      switch (typeof count) {
        case "number":
          if (count > 0) {
            return dupe_number(count | 0, value);
          }
          break;
        case "object":
          if (typeof count.length === "number") {
            return dupe_array(count, value, 0);
          }
          break;
      }
      return [];
    }
    module.exports = dupe;
  }
});

// ../../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "../../node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// ../../node_modules/buffer/index.js
var require_buffer = __commonJS({
  "../../node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf))
              buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name2) {
        if (name2) {
          return `${name2} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name2, actual) {
        return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/typedarray-pool/pool.js
var require_pool = __commonJS({
  "node_modules/typedarray-pool/pool.js"(exports) {
    "use strict";
    var bits = require_twiddle();
    var dup = require_dup();
    var Buffer2 = require_buffer().Buffer;
    if (!global.__TYPEDARRAY_POOL) {
      global.__TYPEDARRAY_POOL = {
        UINT8: dup([32, 0]),
        UINT16: dup([32, 0]),
        UINT32: dup([32, 0]),
        BIGUINT64: dup([32, 0]),
        INT8: dup([32, 0]),
        INT16: dup([32, 0]),
        INT32: dup([32, 0]),
        BIGINT64: dup([32, 0]),
        FLOAT: dup([32, 0]),
        DOUBLE: dup([32, 0]),
        DATA: dup([32, 0]),
        UINT8C: dup([32, 0]),
        BUFFER: dup([32, 0])
      };
    }
    var hasUint8C = typeof Uint8ClampedArray !== "undefined";
    var hasBigUint64 = typeof BigUint64Array !== "undefined";
    var hasBigInt64 = typeof BigInt64Array !== "undefined";
    var POOL = global.__TYPEDARRAY_POOL;
    if (!POOL.UINT8C) {
      POOL.UINT8C = dup([32, 0]);
    }
    if (!POOL.BIGUINT64) {
      POOL.BIGUINT64 = dup([32, 0]);
    }
    if (!POOL.BIGINT64) {
      POOL.BIGINT64 = dup([32, 0]);
    }
    if (!POOL.BUFFER) {
      POOL.BUFFER = dup([32, 0]);
    }
    var DATA = POOL.DATA;
    var BUFFER = POOL.BUFFER;
    exports.free = function free(array) {
      if (Buffer2.isBuffer(array)) {
        BUFFER[bits.log2(array.length)].push(array);
      } else {
        if (Object.prototype.toString.call(array) !== "[object ArrayBuffer]") {
          array = array.buffer;
        }
        if (!array) {
          return;
        }
        var n = array.length || array.byteLength;
        var log_n = bits.log2(n) | 0;
        DATA[log_n].push(array);
      }
    };
    function freeArrayBuffer(buffer) {
      if (!buffer) {
        return;
      }
      var n = buffer.length || buffer.byteLength;
      var log_n = bits.log2(n);
      DATA[log_n].push(buffer);
    }
    function freeTypedArray(array) {
      freeArrayBuffer(array.buffer);
    }
    exports.freeUint8 = exports.freeUint16 = exports.freeUint32 = exports.freeBigUint64 = exports.freeInt8 = exports.freeInt16 = exports.freeInt32 = exports.freeBigInt64 = exports.freeFloat32 = exports.freeFloat = exports.freeFloat64 = exports.freeDouble = exports.freeUint8Clamped = exports.freeDataView = freeTypedArray;
    exports.freeArrayBuffer = freeArrayBuffer;
    exports.freeBuffer = function freeBuffer(array) {
      BUFFER[bits.log2(array.length)].push(array);
    };
    exports.malloc = function malloc(n, dtype) {
      if (dtype === void 0 || dtype === "arraybuffer") {
        return mallocArrayBuffer(n);
      } else {
        switch (dtype) {
          case "uint8":
            return mallocUint8(n);
          case "uint16":
            return mallocUint16(n);
          case "uint32":
            return mallocUint32(n);
          case "int8":
            return mallocInt8(n);
          case "int16":
            return mallocInt16(n);
          case "int32":
            return mallocInt32(n);
          case "float":
          case "float32":
            return mallocFloat(n);
          case "double":
          case "float64":
            return mallocDouble(n);
          case "uint8_clamped":
            return mallocUint8Clamped(n);
          case "bigint64":
            return mallocBigInt64(n);
          case "biguint64":
            return mallocBigUint64(n);
          case "buffer":
            return mallocBuffer(n);
          case "data":
          case "dataview":
            return mallocDataView(n);
          default:
            return null;
        }
      }
      return null;
    };
    function mallocArrayBuffer(n) {
      var n = bits.nextPow2(n);
      var log_n = bits.log2(n);
      var d = DATA[log_n];
      if (d.length > 0) {
        return d.pop();
      }
      return new ArrayBuffer(n);
    }
    exports.mallocArrayBuffer = mallocArrayBuffer;
    function mallocUint8(n) {
      return new Uint8Array(mallocArrayBuffer(n), 0, n);
    }
    exports.mallocUint8 = mallocUint8;
    function mallocUint16(n) {
      return new Uint16Array(mallocArrayBuffer(2 * n), 0, n);
    }
    exports.mallocUint16 = mallocUint16;
    function mallocUint32(n) {
      return new Uint32Array(mallocArrayBuffer(4 * n), 0, n);
    }
    exports.mallocUint32 = mallocUint32;
    function mallocInt8(n) {
      return new Int8Array(mallocArrayBuffer(n), 0, n);
    }
    exports.mallocInt8 = mallocInt8;
    function mallocInt16(n) {
      return new Int16Array(mallocArrayBuffer(2 * n), 0, n);
    }
    exports.mallocInt16 = mallocInt16;
    function mallocInt32(n) {
      return new Int32Array(mallocArrayBuffer(4 * n), 0, n);
    }
    exports.mallocInt32 = mallocInt32;
    function mallocFloat(n) {
      return new Float32Array(mallocArrayBuffer(4 * n), 0, n);
    }
    exports.mallocFloat32 = exports.mallocFloat = mallocFloat;
    function mallocDouble(n) {
      return new Float64Array(mallocArrayBuffer(8 * n), 0, n);
    }
    exports.mallocFloat64 = exports.mallocDouble = mallocDouble;
    function mallocUint8Clamped(n) {
      if (hasUint8C) {
        return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n);
      } else {
        return mallocUint8(n);
      }
    }
    exports.mallocUint8Clamped = mallocUint8Clamped;
    function mallocBigUint64(n) {
      if (hasBigUint64) {
        return new BigUint64Array(mallocArrayBuffer(8 * n), 0, n);
      } else {
        return null;
      }
    }
    exports.mallocBigUint64 = mallocBigUint64;
    function mallocBigInt64(n) {
      if (hasBigInt64) {
        return new BigInt64Array(mallocArrayBuffer(8 * n), 0, n);
      } else {
        return null;
      }
    }
    exports.mallocBigInt64 = mallocBigInt64;
    function mallocDataView(n) {
      return new DataView(mallocArrayBuffer(n), 0, n);
    }
    exports.mallocDataView = mallocDataView;
    function mallocBuffer(n) {
      n = bits.nextPow2(n);
      var log_n = bits.log2(n);
      var cache = BUFFER[log_n];
      if (cache.length > 0) {
        return cache.pop();
      }
      return new Buffer2(n);
    }
    exports.mallocBuffer = mallocBuffer;
    exports.clearCache = function clearCache() {
      for (var i = 0; i < 32; ++i) {
        POOL.UINT8[i].length = 0;
        POOL.UINT16[i].length = 0;
        POOL.UINT32[i].length = 0;
        POOL.INT8[i].length = 0;
        POOL.INT16[i].length = 0;
        POOL.INT32[i].length = 0;
        POOL.FLOAT[i].length = 0;
        POOL.DOUBLE[i].length = 0;
        POOL.BIGUINT64[i].length = 0;
        POOL.BIGINT64[i].length = 0;
        POOL.UINT8C[i].length = 0;
        DATA[i].length = 0;
        BUFFER[i].length = 0;
      }
    };
  }
});

// node_modules/iota-array/iota.js
var require_iota = __commonJS({
  "node_modules/iota-array/iota.js"(exports, module) {
    "use strict";
    function iota(n) {
      var result = new Array(n);
      for (var i = 0; i < n; ++i) {
        result[i] = i;
      }
      return result;
    }
    module.exports = iota;
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports, module) {
    module.exports = function(obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
    }
  }
});

// node_modules/ndarray/ndarray.js
var require_ndarray = __commonJS({
  "node_modules/ndarray/ndarray.js"(exports, module) {
    var iota = require_iota();
    var isBuffer = require_is_buffer();
    var hasTypedArrays = typeof Float64Array !== "undefined";
    function compare1st(a, b) {
      return a[0] - b[0];
    }
    function order() {
      var stride = this.stride;
      var terms = new Array(stride.length);
      var i;
      for (i = 0; i < terms.length; ++i) {
        terms[i] = [Math.abs(stride[i]), i];
      }
      terms.sort(compare1st);
      var result = new Array(terms.length);
      for (i = 0; i < result.length; ++i) {
        result[i] = terms[i][1];
      }
      return result;
    }
    function compileConstructor(dtype, dimension) {
      var className = ["View", dimension, "d", dtype].join("");
      if (dimension < 0) {
        className = "View_Nil" + dtype;
      }
      var useGetters = dtype === "generic";
      if (dimension === -1) {
        var code = "function " + className + "(a){this.data=a;};var proto=" + className + ".prototype;proto.dtype='" + dtype + "';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new " + className + "(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_" + className + "(a){return new " + className + "(a);}";
        var procedure = new Function(code);
        return procedure();
      } else if (dimension === 0) {
        var code = "function " + className + "(a,d) {this.data = a;this.offset = d};var proto=" + className + ".prototype;proto.dtype='" + dtype + "';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function " + className + "_copy() {return new " + className + "(this.data,this.offset)};proto.pick=function " + className + "_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function " + className + "_get(){return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};proto.set=function " + className + "_set(v){return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "};return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
        var procedure = new Function("TrivialArray", code);
        return procedure(CACHED_CONSTRUCTORS[dtype][0]);
      }
      var code = ["'use strict'"];
      var indices = iota(dimension);
      var args = indices.map(function(i2) {
        return "i" + i2;
      });
      var index_str = "this.offset+" + indices.map(function(i2) {
        return "this.stride[" + i2 + "]*i" + i2;
      }).join("+");
      var shapeArg = indices.map(function(i2) {
        return "b" + i2;
      }).join(",");
      var strideArg = indices.map(function(i2) {
        return "c" + i2;
      }).join(",");
      code.push(
        "function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a",
        "this.shape=[" + shapeArg + "]",
        "this.stride=[" + strideArg + "]",
        "this.offset=d|0}",
        "var proto=" + className + ".prototype",
        "proto.dtype='" + dtype + "'",
        "proto.dimension=" + dimension
      );
      code.push(
        "Object.defineProperty(proto,'size',{get:function " + className + "_size(){return " + indices.map(function(i2) {
          return "this.shape[" + i2 + "]";
        }).join("*"),
        "}})"
      );
      if (dimension === 1) {
        code.push("proto.order=[0]");
      } else {
        code.push("Object.defineProperty(proto,'order',{get:");
        if (dimension < 4) {
          code.push("function " + className + "_order(){");
          if (dimension === 2) {
            code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
          } else if (dimension === 3) {
            code.push(
              "var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})"
            );
          }
        } else {
          code.push("ORDER})");
        }
      }
      code.push(
        "proto.set=function " + className + "_set(" + args.join(",") + ",v){"
      );
      if (useGetters) {
        code.push("return this.data.set(" + index_str + ",v)}");
      } else {
        code.push("return this.data[" + index_str + "]=v}");
      }
      code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");
      if (useGetters) {
        code.push("return this.data.get(" + index_str + ")}");
      } else {
        code.push("return this.data[" + index_str + "]}");
      }
      code.push(
        "proto.index=function " + className + "_index(",
        args.join(),
        "){return " + index_str + "}"
      );
      code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function(i2) {
        return ["(typeof i", i2, "!=='number'||i", i2, "<0)?this.shape[", i2, "]:i", i2, "|0"].join("");
      }).join(",") + "," + indices.map(function(i2) {
        return "this.stride[" + i2 + "]";
      }).join(",") + ",this.offset)}");
      var a_vars = indices.map(function(i2) {
        return "a" + i2 + "=this.shape[" + i2 + "]";
      });
      var c_vars = indices.map(function(i2) {
        return "c" + i2 + "=this.stride[" + i2 + "]";
      });
      code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));
      for (var i = 0; i < dimension; ++i) {
        code.push(
          "if(typeof i" + i + "==='number'&&i" + i + ">=0){d=i" + i + "|0;b+=c" + i + "*d;a" + i + "-=d}"
        );
      }
      code.push("return new " + className + "(this.data," + indices.map(function(i2) {
        return "a" + i2;
      }).join(",") + "," + indices.map(function(i2) {
        return "c" + i2;
      }).join(",") + ",b)}");
      code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function(i2) {
        return "a" + i2 + "=this.shape[" + i2 + "]";
      }).join(",") + "," + indices.map(function(i2) {
        return "b" + i2 + "=this.stride[" + i2 + "]";
      }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");
      for (var i = 0; i < dimension; ++i) {
        code.push(
          "if(typeof i" + i + "==='number'){d=i" + i + "|0;if(d<0){c+=b" + i + "*(a" + i + "-1);a" + i + "=ceil(-a" + i + "/d)}else{a" + i + "=ceil(a" + i + "/d)}b" + i + "*=d}"
        );
      }
      code.push("return new " + className + "(this.data," + indices.map(function(i2) {
        return "a" + i2;
      }).join(",") + "," + indices.map(function(i2) {
        return "b" + i2;
      }).join(",") + ",c)}");
      var tShape = new Array(dimension);
      var tStride = new Array(dimension);
      for (var i = 0; i < dimension; ++i) {
        tShape[i] = "a[i" + i + "]";
        tStride[i] = "b[i" + i + "]";
      }
      code.push(
        "proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function(n, idx) {
          return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
        }).join(";"),
        "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}"
      );
      code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");
      for (var i = 0; i < dimension; ++i) {
        code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}");
      }
      code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}");
      code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function(i2) {
        return "shape[" + i2 + "]";
      }).join(",") + "," + indices.map(function(i2) {
        return "stride[" + i2 + "]";
      }).join(",") + ",offset)}");
      var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
      return procedure(CACHED_CONSTRUCTORS[dtype], order);
    }
    function arrayDType(data) {
      if (isBuffer(data)) {
        return "buffer";
      }
      if (hasTypedArrays) {
        switch (Object.prototype.toString.call(data)) {
          case "[object Float64Array]":
            return "float64";
          case "[object Float32Array]":
            return "float32";
          case "[object Int8Array]":
            return "int8";
          case "[object Int16Array]":
            return "int16";
          case "[object Int32Array]":
            return "int32";
          case "[object Uint8Array]":
            return "uint8";
          case "[object Uint16Array]":
            return "uint16";
          case "[object Uint32Array]":
            return "uint32";
          case "[object Uint8ClampedArray]":
            return "uint8_clamped";
          case "[object BigInt64Array]":
            return "bigint64";
          case "[object BigUint64Array]":
            return "biguint64";
        }
      }
      if (Array.isArray(data)) {
        return "array";
      }
      return "generic";
    }
    var CACHED_CONSTRUCTORS = {
      "float32": [],
      "float64": [],
      "int8": [],
      "int16": [],
      "int32": [],
      "uint8": [],
      "uint16": [],
      "uint32": [],
      "array": [],
      "uint8_clamped": [],
      "bigint64": [],
      "biguint64": [],
      "buffer": [],
      "generic": []
    };
    function wrappedNDArrayCtor(data, shape, stride, offset) {
      if (data === void 0) {
        var ctor = CACHED_CONSTRUCTORS.array[0];
        return ctor([]);
      } else if (typeof data === "number") {
        data = [data];
      }
      if (shape === void 0) {
        shape = [data.length];
      }
      var d = shape.length;
      if (stride === void 0) {
        stride = new Array(d);
        for (var i = d - 1, sz = 1; i >= 0; --i) {
          stride[i] = sz;
          sz *= shape[i];
        }
      }
      if (offset === void 0) {
        offset = 0;
        for (var i = 0; i < d; ++i) {
          if (stride[i] < 0) {
            offset -= (shape[i] - 1) * stride[i];
          }
        }
      }
      var dtype = arrayDType(data);
      var ctor_list = CACHED_CONSTRUCTORS[dtype];
      while (ctor_list.length <= d + 1) {
        ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
      }
      var ctor = ctor_list[d + 1];
      return ctor(data, shape, stride, offset);
    }
    module.exports = wrappedNDArrayCtor;
  }
});

// node_modules/gl-react/lib/Uniform.js
var require_Uniform = __commonJS({
  "node_modules/gl-react/lib/Uniform.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Uniform = {
      /**
       * Inject the texture of the previous framebuffer state
       */
      Backbuffer: "_Backbuffer_",
      /**
       * Inject the texture of the previous framebuffer state of another Node pointed by its reference.
       * @param  {Node | Bus} a Node or Bus instance of what you want the backbuffer from. the Node needs to have backbuffering enabled. (in case of Bus, it means its root Node)
       */
      backbufferFrom: (node) => ({
        type: "BackbufferFrom",
        node
      }),
      /**
       * the framebuffer size itself
       */
      Resolution: "_Resolution_",
      /**
       * Inject the size of a given Texture input
       * @param {any} obj the texture input object
       */
      textureSize: (obj) => ({
        type: "TextureSize",
        obj
      }),
      /**
       * Inject the width/height ratio of a given Texture input
       * @param {any} obj the texture input object
       */
      textureSizeRatio: (obj) => ({
        type: "TextureSize",
        obj,
        ratio: true
      })
    };
    var _default = Uniform;
    exports.default = _default;
  }
});

// node_modules/gl-react/lib/GLSL.js
var require_GLSL = __commonJS({
  "node_modules/gl-react/lib/GLSL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.GLSLSymbol = void 0;
    exports.default = GLSL;
    var GLSLSymbol = "GLSL";
    exports.GLSLSymbol = GLSLSymbol;
    function GLSL(strings, ...values) {
      let code = "";
      for (let i = 0; i < strings.length; i++) {
        code += (i === 0 ? "" : values[i - 1]) + strings[i];
      }
      return code;
    }
  }
});

// node_modules/gl-react/lib/Shaders.js
var require_Shaders = __commonJS({
  "node_modules/gl-react/lib/Shaders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    exports.ensureShaderDefinition = ensureShaderDefinition;
    exports.isShaderIdentifier = isShaderIdentifier;
    exports.shaderDefinitionToShaderInfo = shaderDefinitionToShaderInfo;
    exports.shaderInfoEquals = shaderInfoEquals;
    var _invariant = _interopRequireDefault(require_browser());
    var _GLSL = _interopRequireDefault(require_GLSL());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ShaderID = "ShaderID";
    var shaderDefinitions = {};
    var shaderNames = {};
    var shaderResults = {};
    var genShaderId = ((i) => () => (++i).toString())(0);
    var staticVerts = {
      "100": (0, _GLSL.default)`
attribute vec2 _p;
varying vec2 uv;
void main() {
gl_Position = vec4(_p,0.0,1.0);
uv = vec2(0.5, 0.5) * (_p+vec2(1.0, 1.0));
}`,
      "300 es": (0, _GLSL.default)`#version 300 es
in vec2 _p;
out vec2 uv;
void main() {
gl_Position = vec4(_p,0.0,1.0);
uv = vec2(0.5, 0.5) * (_p+vec2(1.0, 1.0));
}`
    };
    function isShaderIdentifier(shaderIdentifier) {
      return typeof shaderIdentifier === "object" && !!shaderIdentifier && shaderIdentifier.type === ShaderID && typeof shaderIdentifier.id === "string";
    }
    function ensureShaderDefinition(definition, ctx = "") {
      (0, _invariant.default)(definition && typeof definition.frag === "string", "A `frag` GLSL code (string) is required" + ctx);
      return definition;
    }
    var versionDef = "#version";
    function inferGLSLVersion(glsl) {
      const i = glsl.indexOf("\n");
      const line1 = i > -1 ? glsl.slice(0, i) : glsl;
      if (line1.startsWith(versionDef)) {
        return line1.slice(versionDef.length + 1);
      }
      return "100";
    }
    var addGLSLName = (glsl, name2) => !name2 ? glsl : glsl + "\n#define SHADER_NAME " + name2 + "\n";
    function shaderDefinitionToShaderInfo({
      frag,
      vert
    }, name2) {
      frag = frag.trim();
      const version = inferGLSLVersion(frag);
      if (vert) {
        vert = vert.trim();
        const vertVersion = inferGLSLVersion(vert);
        if (version !== vertVersion) {
          throw new Error("GLSL shader vert and frag version must match");
        }
      } else {
        vert = staticVerts[version];
        if (!vert) {
          throw new Error("gl-react: could not find static vertex shader for GLSL version '" + version + "'");
        }
      }
      frag = addGLSLName(frag, name2);
      vert = addGLSLName(vert, name2);
      return {
        frag,
        vert
      };
    }
    function shaderInfoEquals(s1, s2) {
      return s1.frag === s2.frag && s1.vert === s2.vert;
    }
    var Shaders = global.__glReactShaders = global.__glReactShaders || {
      /**
       * @memberof Shaders
       * @param {ShadersDefinition} shadersDef - an object that statically define all shaders.
       * @returns {ShadersSheet}, an object map that returns a ShaderIdentifier for each shader key defined in the shaders definition.
       * @example
       *  const shaders = Shaders.create({
       *    helloGL: {
       *      frag: GLSL`...`
       *    }
       *  });
       *  ...
       *  <Node shader={shaders.helloGL} />
       */
      create(shadersDef) {
        const sheet = {};
        Object.keys(shadersDef).forEach((k) => {
          const definition = ensureShaderDefinition(shadersDef[k], " in Shaders.create({ " + k + ": ... })");
          const id = genShaderId();
          const shaderId = Object.freeze({
            type: ShaderID,
            id
          });
          shaderDefinitions[id] = definition;
          shaderNames[id] = k;
          sheet[k] = shaderId;
          const result = shaderDefinitionToShaderInfo(definition, k);
          shaderResults[id] = result;
        });
        return sheet;
      },
      getName(shaderIdentifier) {
        return (shaderNames[shaderIdentifier.id] || "???") + `#${String(shaderIdentifier.id)}`;
      },
      getShortName(shaderIdentifier) {
        return shaderNames[shaderIdentifier.id] || "???";
      },
      get(shaderIdentifier) {
        (0, _invariant.default)(shaderIdentifier.id in shaderDefinitions, "Shader %s does not exist. Make sure you don't have gl-react dup issue: `npm ls gl-react`", shaderIdentifier.id);
        return shaderResults[shaderIdentifier.id];
      }
    };
    var _default = Shaders;
    exports.default = _default;
  }
});

// node_modules/gl-react/lib/helpers/invariantNoDependentsLoop.js
var require_invariantNoDependentsLoop = __commonJS({
  "node_modules/gl-react/lib/helpers/invariantNoDependentsLoop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = invariantNoDependentsLoop;
    var _invariant = _interopRequireDefault(require_browser());
    var _Node = _interopRequireDefault(require_Node());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function invariantNoDependentsLoop(base, node) {
      (0, _invariant.default)(base !== node, "gl-react: Found a loop in the rendering graph.\nIf you want to get back previous state, please use `backbuffering` instead");
      if (node instanceof _Node.default) {
        for (let i = 0; i < node.dependents.length; i++) {
          invariantNoDependentsLoop(base, node.dependents[i]);
        }
      }
    }
  }
});

// node_modules/gl-react/lib/genId.js
var require_genId = __commonJS({
  "node_modules/gl-react/lib/genId.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var genId = ((i) => () => ++i)(0);
    var _default = genId;
    exports.default = _default;
  }
});

// node_modules/gl-react/lib/Node.js
var require_Node = __commonJS({
  "node_modules/gl-react/lib/Node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _invariant = _interopRequireDefault(require_browser());
    var _react = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _typedarrayPool = _interopRequireDefault(require_pool());
    var _ndarray = _interopRequireDefault(require_ndarray());
    var _Uniform = _interopRequireDefault(require_Uniform());
    var _Bus = _interopRequireDefault(require_Bus());
    var _Shaders = _interopRequireWildcard(require_Shaders());
    var _invariantNoDependentsLoop = _interopRequireDefault(require_invariantNoDependentsLoop());
    var _genId = _interopRequireDefault(require_genId());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var blendFuncAliases = {
      zero: "ZERO",
      one: "ONE",
      "src color": "SRC_COLOR",
      "one minus src color": "ONE_MINUS_SRC_COLOR",
      "src alpha": "SRC_ALPHA",
      "one minus src alpha": "ONE_MINUS_SRC_ALPHA",
      "dst color": "DST_COLOR",
      "one minus dst color": "ONE_MINUS_DST_COLOR",
      "dst alpha": "DST_ALPHA",
      "one minus dst alpha": "ONE_MINUS_DST_ALPHA",
      "constant color": "CONSTANT_COLOR",
      "one minus constant color": "ONE_MINUS_CONSTANT_COLOR",
      "constant alpha": "CONSTANT_ALPHA",
      "one minus constant alpha": "ONE_MINUS_CONSTANT_ALPHA",
      "src alpha saturate": "SRC_ALPHA_SATURATE"
    };
    var isBackbuffer = (obj) => {
      if (obj === "Backbuffer") {
        console.warn('Backbuffer is deprecated, use Uniform.Backbuffer instead: `import {Uniform} from "gl-react"`');
        return true;
      }
      return obj === _Uniform.default.Backbuffer;
    };
    var isBackbufferFrom = (obj) => obj && typeof obj === "object" && obj.type === "BackbufferFrom";
    var isTextureSizeGetter = (obj) => obj && typeof obj === "object" && obj.type === "TextureSize";
    var nodeWidthHeight = ({
      width,
      height
    }, {
      glSizable
    }) => {
      if (width && height)
        return [width, height];
      const [cw, ch] = glSizable.getGLSize();
      return [width || cw, height || ch];
    };
    var mapBlendFunc = (gl, name2) => {
      if (name2 in gl)
        return gl[name2];
      if (name2 in blendFuncAliases) {
        const id = blendFuncAliases[name2];
        if (id in gl)
          return gl[id];
      }
      console.warn("Invalid blendFunc. Got:", name2);
    };
    var parseWrap = (gl, w) => {
      switch (w) {
        case "clamp to edge":
          return gl.CLAMP_TO_EDGE;
        case "repeat":
          return gl.REPEAT;
        case "mirrored repeat":
          return gl.MIRRORED_REPEAT;
        default:
          console.warn("Invalid wrap. Got:", w);
          return gl.CLAMP_TO_EDGE;
      }
    };
    var mergeArrays = (a, b) => {
      const t = [];
      const length = Math.max(a.length, b.length);
      for (let i = 0; i < length; i++) {
        t[i] = b[i] || a[i];
      }
      return t;
    };
    var parseInterpolation = (gl, i) => {
      switch (i) {
        case "linear":
          return gl.LINEAR;
        case "nearest":
          return gl.NEAREST;
        default:
          console.warn("Invalid interpolation. Got:", i);
          return gl.LINEAR;
      }
    };
    var createFBO = (gl, width, height) => {
      var handle = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, handle);
      var color = gl.createTexture();
      if (!color)
        throw new Error("createTexture returned null");
      gl.bindTexture(gl.TEXTURE_2D, color);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, color, 0);
      return {
        handle,
        color,
        bind: () => {
          gl.bindFramebuffer(gl.FRAMEBUFFER, handle);
          gl.viewport(0, 0, width, height);
        },
        syncSize: (w, h) => {
          if (w !== width || h !== height) {
            width = w;
            height = h;
            gl.bindTexture(gl.TEXTURE_2D, color);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          }
        },
        dispose: () => {
          gl.deleteFramebuffer(handle);
          gl.deleteTexture(color);
        }
      };
    };
    var defaultTextureOptions = {
      interpolation: "linear",
      wrap: ["clamp to edge", "clamp to edge"]
    };
    var applyTextureOptions = (gl, partialOpts) => {
      const opts = _objectSpread(_objectSpread({}, defaultTextureOptions), partialOpts);
      let filter = parseInterpolation(gl, opts.interpolation);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
      let wrapS, wrapT;
      if (Array.isArray(opts.wrap)) {
        if (opts.wrap.length !== 2) {
          console.warn("textureOptions wrap: should be an array of 2 values. Got:", opts.wrap);
          wrapS = wrapT = gl.CLAMP_TO_EDGE;
        } else {
          wrapS = parseWrap(gl, opts.wrap[0]);
          wrapT = parseWrap(gl, opts.wrap[1]);
        }
      } else {
        wrapS = wrapT = parseWrap(gl, opts.wrap);
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
    };
    var NodePropTypes = {
      shader: _propTypes.default.object.isRequired,
      uniformsOptions: _propTypes.default.object,
      uniforms: _propTypes.default.object,
      ignoreUnusedUniforms: _propTypes.default.any,
      sync: _propTypes.default.bool,
      width: _propTypes.default.number,
      height: _propTypes.default.number,
      children: _propTypes.default.any,
      backbuffering: _propTypes.default.bool,
      blendFunc: _propTypes.default.object,
      clear: _propTypes.default.object,
      onDraw: _propTypes.default.func
    };
    var Node = class extends _react.Component {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "drawProps", this.props);
        _defineProperty(this, "context", void 0);
        _defineProperty(this, "framebuffer", void 0);
        _defineProperty(this, "backbuffer", void 0);
        _defineProperty(this, "_needsRedraw", false);
        _defineProperty(this, "capturePixelsArray", void 0);
        _defineProperty(this, "id", (0, _genId.default)());
        _defineProperty(this, "uniformsBus", {});
        _defineProperty(this, "dependencies", []);
        _defineProperty(this, "dependents", []);
        _defineProperty(this, "_resolveElement", (uniform, value, index) => {
          if (!_react.default.isValidElement(value)) {
            if (typeof value === "function") {
              value = value(this.redraw);
              if (!_react.default.isValidElement(value)) {
                return;
              }
            } else {
              return;
            }
          }
          return _react.default.createElement(_Bus.default, {
            key: uniform + (index ? "." + index : ""),
            uniform,
            index
          }, value);
        });
        _defineProperty(this, "_renderUniformElement", (key) => {
          const {
            uniforms
          } = this.props;
          let value = uniforms[key];
          return Array.isArray(value) ? value.map((v, i) => this._resolveElement(key, v, i)) : this._resolveElement(key, value, 0);
        });
        _defineProperty(this, "redraw", () => {
          if (!this._needsRedraw) {
            this._needsRedraw = true;
            this.dependents.forEach((d) => d.redraw());
          }
        });
        _defineProperty(this, "flush", () => {
          this.context.glSurface._draw();
        });
        _defineProperty(this, "_latestShaderInfo", void 0);
        _defineProperty(this, "_shader", void 0);
      }
      getChildContext() {
        return {
          glParent: this,
          glSizable: this
        };
      }
      componentDidMount() {
        const {
          glSurface: {
            gl
          }
        } = this.context;
        if (gl)
          this._prepareGLObjects(gl);
        this.context.glParent._addGLNodeChild(this);
        this.redraw();
        if (this.props.sync)
          this.flush();
      }
      componentWillUnmount() {
        const {
          capturePixelsArray
        } = this;
        this._destroyGLObjects();
        if (capturePixelsArray) {
          _typedarrayPool.default.freeUint8(capturePixelsArray);
        }
        this._needsRedraw = false;
        this.context.glParent._removeGLNodeChild(this);
        this.dependencies.forEach((d) => d._removeDependent(this));
      }
      _syncNextDrawProps(nextProps, nextContext) {
        const nextWidthHeight = nodeWidthHeight(nextProps, nextContext);
        if (this.framebuffer) {
          this.framebuffer.syncSize(...nextWidthHeight);
        }
        if (this.backbuffer) {
          this.backbuffer.syncSize(...nextWidthHeight);
        }
        (0, _invariant.default)(nextProps.backbuffering === this.drawProps.backbuffering, "Node backbuffering prop must not changed. (not yet supported)");
        this.drawProps = nextProps;
      }
      render() {
        const {
          children,
          uniforms
        } = this.props;
        const {
          glSurface: {
            RenderLessElement
          }
        } = this.context;
        return _react.default.createElement(RenderLessElement, null, children, Object.keys(uniforms).map(this._renderUniformElement));
      }
      componentDidUpdate() {
        this._syncNextDrawProps(this.props, this.context);
        this.redraw();
        if (this.props.sync)
          this.flush();
      }
      getGLShortName() {
        const {
          shader
        } = this.drawProps;
        const shaderName = (0, _Shaders.isShaderIdentifier)(shader) ? (
          // $FlowFixMe FIXME
          _Shaders.default.getShortName(shader)
        ) : "<inline>";
        return `Node(${shaderName})`;
      }
      getGLName() {
        const {
          shader
        } = this.drawProps;
        const shaderName = (0, _Shaders.isShaderIdentifier)(shader) ? (
          // $FlowFixMe FIXME
          _Shaders.default.getName(shader)
        ) : "<inline>";
        return `Node#${this.id}(${shaderName})`;
      }
      getGLSize() {
        return nodeWidthHeight(this.drawProps, this.context);
      }
      getGLOutput() {
        const {
          framebuffer
        } = this;
        (0, _invariant.default)(framebuffer, "Node#getGLOutput: framebuffer is not defined. It cannot be called on a root Node");
        return framebuffer.color;
      }
      getGLBackbufferOutput() {
        const {
          backbuffer
        } = this;
        (0, _invariant.default)(backbuffer, "Node#getGLBackbufferOutput: backbuffer is not defined. Make sure `backbuffering` prop is defined");
        return backbuffer.color;
      }
      /**
       * Imperatively set the props with a partial subset of props to apply.
       * This is an escape hatch to perform a redraw with different props without having to trigger a new React draw. Only use it when reaching a performance bottleneck.
       * NB: at any time, render() needs to consistently render the same props you set in setDrawProps to avoid any potential blink (if a React draw would occur).
       * @param {Props} patch a subset of props to apply on top of the previous draw props.
       */
      setDrawProps(patch) {
        const nextProps = _objectSpread(_objectSpread({}, this.drawProps), patch);
        this._syncNextDrawProps(nextProps, this.context);
        this.redraw();
        if (nextProps.sync)
          this.flush();
      }
      /**
       * Capture the node pixels.
       * Without parameters, it will capture the full rectangle,
       * otherwise you can provide (x, y) or (x, y, w, h) to provide a subset of this rectangle.
       */
      capture(x, y, w, h) {
        const [width, height] = this.getGLSize();
        const {
          gl
        } = this.context.glSurface;
        (0, _invariant.default)(gl, "gl is no longer available");
        if (x === void 0)
          x = 0;
        if (y === void 0)
          y = 0;
        if (w === void 0)
          w = width - x;
        if (h === void 0)
          h = height - y;
        (0, _invariant.default)(x >= 0 && x + w <= width && y >= 0 && y + h <= height, "capture(%s,%s,%s,%s): requested rectangle is out of bounds (%s,%s)", x, y, w, h, width, height);
        const size = w * h * 4;
        const pixels = this._captureAlloc(size);
        this._bind();
        gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        return (0, _ndarray.default)(pixels, [h, w, 4]).step(-1, 1, 1).transpose(1, 0, 2);
      }
      /**
       * Schedule a redraw of this node and all dependent nodes.
       *
       * @function
       */
      _destroyGLObjects() {
        const {
          glSurface
        } = this.context;
        if (glSurface.glIsAvailable()) {
          const {
            framebuffer,
            backbuffer,
            _shader
          } = this;
          if (_shader) {
            _shader.dispose();
          }
          if (framebuffer) {
            framebuffer.dispose();
          }
          if (backbuffer) {
            backbuffer.dispose();
          }
        }
        delete this._shader;
        delete this.framebuffer;
        delete this.backbuffer;
      }
      _prepareGLObjects(gl) {
        const [width, height] = this.getGLSize();
        const {
          glParent,
          glSurface
        } = this.context;
        if (glParent === glSurface) {
          (0, _invariant.default)(!this.drawProps.backbuffering, "`backbuffering` is currently not supported for a Root Node. Try to wrap %s in a <LinearCopy> or <NearestCopy>.", this.getGLName());
        } else {
          const fbo = createFBO(gl, width, height);
          this.framebuffer = fbo;
          if (this.drawProps.backbuffering) {
            const fbo2 = createFBO(gl, width, height);
            this.backbuffer = fbo2;
          }
        }
      }
      _onContextLost() {
        this.dependencies.forEach((d) => d._onContextLost());
        this._destroyGLObjects();
      }
      _onContextRestored(gl) {
        this._prepareGLObjects(gl);
        this.dependencies.forEach((d) => d._onContextRestored(gl));
        this._needsRedraw = true;
      }
      _addGLNodeChild(node) {
      }
      _removeGLNodeChild(node) {
      }
      _addUniformBus(uniformBus, uniformName, index) {
        const array = this.uniformsBus[uniformName] || (this.uniformsBus[uniformName] = []);
        array[index] = uniformBus;
      }
      _removeUniformBus(uniformBus, uniformName, index) {
        const array = this.uniformsBus[uniformName] || (this.uniformsBus[uniformName] = []);
        if (array[index] === uniformBus) {
          array[index] = null;
        }
      }
      _addDependent(node) {
        const i = this.dependents.indexOf(node);
        if (i === -1) {
          (0, _invariantNoDependentsLoop.default)(this, node);
          this.dependents.push(node);
        }
      }
      _removeDependent(node) {
        const i = this.dependents.indexOf(node);
        if (i !== -1) {
          this.dependents.splice(i, 1);
        }
      }
      _syncDependencies(newdeps) {
        const olddeps = this.dependencies;
        const additions = newdeps.filter((node) => olddeps.indexOf(node) === -1);
        const deletions = olddeps.filter((node) => newdeps.indexOf(node) === -1);
        additions.forEach((d) => d._addDependent(this));
        deletions.forEach((d) => d._removeDependent(this));
        this.dependencies = newdeps;
        return [additions, deletions];
      }
      _bind() {
        if (this.framebuffer) {
          this.framebuffer.bind();
        } else {
          this.context.glSurface._bindRootNode();
        }
      }
      _captureAlloc(size) {
        let {
          capturePixelsArray
        } = this;
        if (capturePixelsArray && size !== capturePixelsArray.length) {
          _typedarrayPool.default.freeUint8(capturePixelsArray);
          capturePixelsArray = null;
        }
        const pixels = capturePixelsArray || _typedarrayPool.default.mallocUint8(size);
        this.capturePixelsArray = pixels;
        return pixels;
      }
      // in case of inline shader, a Node currently hold a Node
      _getShader(shaderProp) {
        const {
          glSurface
        } = this.context;
        const nodeName = this.getGLName();
        (0, _invariant.default)(shaderProp, nodeName + ": shader prop must be provided");
        if ((0, _Shaders.isShaderIdentifier)(shaderProp)) {
          return glSurface._getShader(shaderProp);
        }
        const shaderInfo = (0, _Shaders.shaderDefinitionToShaderInfo)((0, _Shaders.ensureShaderDefinition)(shaderProp, " in " + nodeName), nodeName);
        const latestShaderInfo = this._latestShaderInfo;
        let shader = this._shader;
        if (!shader || !latestShaderInfo || !(0, _Shaders.shaderInfoEquals)(latestShaderInfo, shaderInfo)) {
          if (shader) {
            shader.dispose();
            delete this._shader;
          }
          shader = glSurface._makeShader(shaderInfo);
          this._latestShaderInfo = shaderInfo;
          this._shader = shader;
        }
        return shader;
      }
      _draw() {
        const {
          glSurface
        } = this.context;
        const {
          gl
        } = glSurface;
        const visitors = glSurface.getVisitors();
        const nodeName = this.getGLName();
        if (!gl || !this._needsRedraw) {
          visitors.forEach((v) => v.onNodeDrawSkipped(this));
          return;
        }
        const {
          backbuffering,
          uniforms,
          uniformsOptions,
          shader: shaderProp,
          blendFunc,
          clear,
          onDraw,
          ignoreUnusedUniforms
        } = this.drawProps;
        if (!this.framebuffer) {
          const {
            glSizable
          } = this.context;
          const [width, height] = glSizable.getGLSize();
          const [nw, nh] = this.getGLSize();
          (0, _invariant.default)(nw === width && nh === height, nodeName + " is root but have overrided {width=%s,height=%s} which doesn't match Surface size {width=%s,height=%s}. Try to wrap your Node in a <NearestCopy> or <LinearCopy>", nw, nh, width, height);
        }
        const shader = this._getShader(shaderProp);
        this._needsRedraw = false;
        const {
          types
        } = shader;
        const glRedrawableDependencies = [];
        const pendingTextures = [];
        let units = 0;
        const usedUniforms = Object.keys(types.uniforms);
        const providedUniforms = Object.keys(uniforms);
        const {
          uniformsBus
        } = this;
        for (let k in uniformsBus) {
          if (!(k in uniforms)) {
            providedUniforms.push(k);
          }
        }
        const textureUnits = /* @__PURE__ */ new Map();
        const prepareTexture = (initialObj, uniformOptions, uniformKeyName) => {
          let obj = initialObj, dependency, result;
          if (typeof obj === "function") {
            obj = obj(this.redraw);
          }
          if (!obj) {
            if (obj === void 0) {
              console.warn(`${nodeName}, uniform '${uniformKeyName}' is undefined.If you explicitely want to clear a texture, set it to null.`);
            }
          } else if (isBackbuffer(obj)) {
            if (!this.drawProps.backbuffering) {
              console.warn(`${nodeName}, uniform ${uniformKeyName}: you must set \`backbuffering\` on Node when using Backbuffer`);
            }
            result = {
              glNode: this,
              glNodePickBackbuffer: true
            };
          } else if (isBackbufferFrom(obj)) {
            (0, _invariant.default)(typeof obj === "object", "invalid backbufferFromNode. Got: %s", obj);
            let node = obj.node;
            if (node instanceof _Bus.default) {
              node = node.getGLRenderableNode();
              (0, _invariant.default)(node, "backbufferFromNode(bus) but bus.getGLRenderableNode() is %s", node);
            }
            (0, _invariant.default)(node instanceof Node, "invalid backbufferFromNode(obj): obj must be an instanceof Node or Bus. Got: %s", obj);
            if (!node.drawProps.backbuffering) {
              console.warn(`${nodeName}, uniform ${uniformKeyName}: you must set \`backbuffering\` on the Node referenced in backbufferFrom(${node.getGLName()})`);
            }
            result = {
              glNode: node,
              glNodePickBackbuffer: true
            };
          } else if (obj instanceof Node) {
            dependency = obj;
            result = {
              glNode: obj
            };
          } else if (obj instanceof _Bus.default) {
            const node = obj.getGLRenderableNode();
            if (node) {
              dependency = node;
              result = {
                glNode: node
              };
            } else {
              dependency = obj;
              const renderable = obj.getGLRenderableContent();
              if (!renderable) {
                console.warn(`${nodeName}, uniform ${uniformKeyName}: child is not renderable. Got:`, renderable);
                result = {
                  directTexture: null
                };
              } else {
                obj = renderable;
              }
            }
          }
          if (!result && obj) {
            const {
              loader,
              input
            } = glSurface._resolveTextureLoader(obj);
            if (!loader) {
              console.warn(`${nodeName}, uniform ${uniformKeyName}: no loader found for value`, input, obj);
            } else {
              const t = loader.get(input);
              if (t) {
                loader.update(input);
                result = {
                  directTexture: t.texture,
                  directTextureSize: [t.width, t.height]
                };
              } else {
                const p = loader.load(input);
                pendingTextures.push(p);
              }
            }
          }
          if (dependency)
            glRedrawableDependencies.push(dependency);
          const textureOptions = result ? uniformOptions : null;
          const getMetaInfo = () => ({
            initialObj,
            obj,
            dependency,
            textureOptions
          });
          const getSize = () => {
            const fallback = [2, 2];
            return result ? "directTextureSize" in result ? result.directTextureSize : result.glNode ? result.glNode.getGLSize() : fallback : fallback;
          };
          const prepare = () => {
            const texture = result && (result.directTexture || result.glNode && (result.glNodePickBackbuffer ? result.glNode.getGLBackbufferOutput() : result.glNode.getGLOutput())) || glSurface.getEmptyTexture();
            if (textureUnits.has(texture)) {
              return textureUnits.get(texture);
            }
            const value = units++;
            gl.activeTexture(gl.TEXTURE0 + value);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            applyTextureOptions(gl, textureOptions);
            textureUnits.set(texture, value);
            return value;
          };
          return {
            getMetaInfo,
            getSize,
            prepare
          };
        };
        const prepareUniform = (key) => {
          const uniformType = types.uniforms[key];
          if (!uniformType) {
            const ignoredWarn = ignoreUnusedUniforms === true || ignoreUnusedUniforms instanceof Array && ignoreUnusedUniforms.includes(key);
            if (!ignoredWarn) {
              console.warn(`${nodeName} uniform '${key}' is not declared, nor used, in your shader code`);
            }
            return {
              key,
              value: void 0
            };
          }
          const uniformValue = uniforms[key];
          usedUniforms.splice(usedUniforms.indexOf(key), 1);
          if (uniformType === "sampler2D") {
            const uniformBus = uniformsBus[key];
            const {
              getMetaInfo,
              prepare
            } = prepareTexture(uniformBus && uniformBus[0] || uniformValue, uniformsOptions[key], key);
            return {
              key,
              type: uniformType,
              getMetaInfo,
              prepare
            };
          } else if (uniformValue === _Uniform.default.Resolution) {
            return {
              key,
              type: uniformType,
              value: this.getGLSize()
            };
          } else if (isTextureSizeGetter(uniformValue)) {
            (0, _invariant.default)(uniformValue && typeof uniformValue === "object", "unexpected textureSize object. Got: %s", uniformValue);
            const {
              getSize
            } = prepareTexture(uniformValue.obj, null, key);
            const size = getSize();
            if (!size) {
              console.warn(`${nodeName}, uniform ${key}: texture size is undetermined`);
            }
            const value = uniformValue.ratio ? size ? size[0] / size[1] : 1 : size || [0, 0];
            return {
              key,
              type: uniformType,
              value
            };
          } else if (Array.isArray(uniformType) && uniformType[0] === "sampler2D") {
            let values;
            const uniformBus = uniformsBus[key];
            const v = mergeArrays(Array.isArray(uniformValue) ? uniformValue : [], Array.isArray(uniformBus) ? uniformBus : []);
            if (!v.length) {
              console.warn(`${nodeName}, uniform '${key}' should be an array of textures.`);
              values = uniformType.map(() => null);
            } else if (v.length !== uniformType.length) {
              console.warn(`${nodeName}, uniform '${key}' should be an array of exactly ${uniformType.length} textures (not ${v.length}).`);
              values = uniformType.map(() => null);
            } else {
              values = v;
            }
            const uniformOptions = uniformsOptions[key];
            const all = values.map((value, i) => prepareTexture(value, uniformOptions, key + "[" + i + "]"));
            return {
              key,
              type: uniformType,
              getMetaInfo: () => all.reduce((acc, o) => acc.concat(o.getMetaInfo()), []),
              prepare: () => all.map((o) => o.prepare())
            };
          } else {
            if (uniformValue === void 0) {
              console.warn(`${nodeName}, uniform '${key}' is undefined.`);
            }
            return {
              key,
              type: uniformType,
              value: uniformValue
            };
          }
        };
        const preparedUniforms = providedUniforms.map(prepareUniform);
        if (usedUniforms.length !== 0) {
          console.warn(nodeName + ": Missing uniforms: " + usedUniforms.map((u) => `'${u}'`).join(", ") + "\nall uniforms must be provided because implementations might share and reuse a Shader Program");
        }
        if (pendingTextures.length > 0) {
          Promise.all(pendingTextures).then(this.redraw);
          visitors.forEach((v) => v.onNodeDrawSkipped(this));
          return;
        }
        visitors.forEach((v) => v.onNodeDrawStart(this));
        const [additions, deletions] = this._syncDependencies(glRedrawableDependencies);
        visitors.forEach((v) => v.onNodeSyncDeps(this, additions, deletions));
        if (backbuffering) {
          const {
            backbuffer,
            framebuffer
          } = this;
          this.backbuffer = framebuffer;
          if (backbuffer) {
            this.framebuffer = backbuffer;
          }
        }
        const drawDep = (d) => d._draw();
        this.dependencies.forEach(drawDep);
        visitors.forEach((v) => v.onNodeDraw(this, preparedUniforms));
        shader.bind();
        this._bind();
        preparedUniforms.forEach((obj) => {
          const value = obj.prepare ? obj.prepare() : obj.value;
          if (value !== void 0) {
            shader.uniforms[obj.key] = value;
          }
        });
        if (blendFunc) {
          const src = mapBlendFunc(gl, blendFunc.src);
          const dst = mapBlendFunc(gl, blendFunc.dst);
          if (src && dst)
            gl.blendFunc(src, dst);
        }
        if (clear) {
          gl.clearColor(...clear.color);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }
        gl.drawArrays(gl.TRIANGLES, 0, 3);
        if (onDraw)
          onDraw();
        visitors.forEach((v) => v.onNodeDrawEnd(this));
      }
    };
    exports.default = Node;
    _defineProperty(Node, "propTypes", NodePropTypes);
    _defineProperty(Node, "defaultProps", {
      uniformsOptions: {},
      uniforms: {},
      blendFunc: {
        // FIXME should this actually just be null by default? opt-in?
        src: "src alpha",
        dst: "one minus src alpha"
      },
      clear: {
        color: [0, 0, 0, 0]
      }
    });
    _defineProperty(Node, "contextTypes", {
      glParent: _propTypes.default.object.isRequired,
      glSurface: _propTypes.default.object.isRequired,
      glSizable: _propTypes.default.object.isRequired
    });
    _defineProperty(Node, "childContextTypes", {
      glParent: _propTypes.default.object.isRequired,
      glSizable: _propTypes.default.object.isRequired
    });
  }
});

// node_modules/gl-react/lib/Bus.js
var require_Bus = __commonJS({
  "node_modules/gl-react/lib/Bus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _invariant = _interopRequireDefault(require_browser());
    var _react = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _Node = _interopRequireDefault(require_Node());
    var _invariantNoDependentsLoop = _interopRequireDefault(require_invariantNoDependentsLoop());
    var _genId = _interopRequireDefault(require_genId());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var Bus = class extends _react.Component {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "id", (0, _genId.default)());
        _defineProperty(this, "context", void 0);
        _defineProperty(this, "dependents", []);
        _defineProperty(this, "glNode", null);
        _defineProperty(this, "glBusRootNode", void 0);
        _defineProperty(this, "onRef", (ref) => {
          this.glBusRootNode = ref;
        });
        _defineProperty(this, "redraw", () => {
          this.dependents.forEach((d) => d.redraw());
        });
        _defineProperty(this, "_draw", () => {
        });
      }
      componentDidMount() {
        const {
          uniform,
          index
        } = this.props;
        if (uniform) {
          const {
            glParent
          } = this.context;
          (0, _invariant.default)(glParent instanceof _Node.default, 'a <Bus uniform=".." /> needs to be inside a Node');
          glParent._addUniformBus(this, uniform, index);
        }
        this.redraw();
      }
      componentWillUnmount() {
        const {
          uniform,
          index
        } = this.props;
        if (uniform) {
          const {
            glParent
          } = this.context;
          (0, _invariant.default)(glParent instanceof _Node.default, 'a <Bus uniform=".." /> needs to be inside a Node');
          glParent._removeUniformBus(this, uniform, index);
        }
      }
      componentDidUpdate({
        uniform: oldUniform,
        index: oldIndex
      }) {
        const {
          uniform,
          index
        } = this.props;
        if (uniform && (uniform !== oldUniform || index !== oldIndex)) {
          const {
            glParent
          } = this.context;
          (0, _invariant.default)(glParent instanceof _Node.default, 'a <Bus uniform=".." /> needs to be inside a Node');
          if (oldUniform)
            glParent._removeUniformBus(this, oldUniform, oldIndex);
          glParent._addUniformBus(this, uniform, index);
        }
        this.redraw();
      }
      getChildContext() {
        return {
          glParent: this
        };
      }
      _addGLNodeChild(node) {
        this.glNode = node;
        this.context.glParent.redraw();
      }
      _removeGLNodeChild(node) {
        this.glNode = null;
      }
      _addDependent(node) {
        const i = this.dependents.indexOf(node);
        if (i === -1) {
          (0, _invariantNoDependentsLoop.default)(this, node);
          this.dependents.push(node);
        }
      }
      _removeDependent(node) {
        const i = this.dependents.indexOf(node);
        if (i !== -1)
          this.dependents.splice(i, 1);
      }
      getGLRenderableNode() {
        return this.glNode;
      }
      getGLRenderableContent() {
        const {
          mapRenderableContent
        } = this.context.glSurface;
        const {
          glBusRootNode
        } = this;
        return glBusRootNode && mapRenderableContent ? mapRenderableContent(glBusRootNode) : null;
      }
      getGLName() {
        return `Bus(${this.glNode ? this.glNode.getGLName() : String(this.getGLRenderableContent())})`;
      }
      getGLShortName() {
        const content = this.getGLRenderableContent();
        const shortContentName = String(content && content.constructor && content.constructor.name || content);
        return `Bus(${this.glNode ? this.glNode.getGLShortName() : shortContentName})`;
      }
      /**
       * Capture the underlying Node pixels.
       * NB it only works for nodes, not for content like video/canvas.
       */
      capture(x, y, w, h) {
        (0, _invariant.default)(this.glNode, "Bus does not contain any Node");
        return this.glNode.capture(x, y, w, h);
      }
      _onContextLost() {
        const {
          glNode
        } = this;
        if (glNode)
          glNode._onContextLost();
      }
      _onContextRestored(gl) {
        const {
          glNode
        } = this;
        if (glNode)
          glNode._onContextRestored(gl);
      }
      render() {
        const {
          children
        } = this.props;
        const {
          glSurface: {
            RenderLessElement,
            mapRenderableContent
          }
        } = this.context;
        return _react.default.createElement(RenderLessElement, {
          ref: mapRenderableContent ? this.onRef : void 0
        }, typeof children === "function" ? children(this.redraw) : children);
      }
    };
    exports.default = Bus;
    _defineProperty(Bus, "defaultProps", {
      index: 0
    });
    _defineProperty(Bus, "contextTypes", {
      glParent: _propTypes.default.object.isRequired,
      glSurface: _propTypes.default.object.isRequired
    });
    _defineProperty(Bus, "childContextTypes", {
      glParent: _propTypes.default.object.isRequired
    });
  }
});

// node_modules/gl-react/lib/connectSize.js
var require_connectSize = __commonJS({
  "node_modules/gl-react/lib/connectSize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var connectSize = (GLComponent) => {
      var _class;
      return _class = class extends _react.Component {
        constructor(...args) {
          super(...args);
          _defineProperty(this, "context", void 0);
        }
        getGLSize() {
          const {
            props: {
              width,
              height
            },
            context: {
              glSizable
            }
          } = this;
          if (width && height)
            return [width, height];
          const [cw, ch] = glSizable.getGLSize();
          return [width || cw, height || ch];
        }
        getChildContext() {
          return {
            glSizable: this
          };
        }
        render() {
          const {
            onConnectSizeComponentRef
          } = this.props;
          const [width, height] = this.getGLSize();
          return _react.default.createElement(GLComponent, _extends({
            ref: onConnectSizeComponentRef
          }, this.props, {
            width,
            height
          }));
        }
      }, _defineProperty(_class, "displayName", `connectSize(${GLComponent.displayName || GLComponent.name || "?"})`), _defineProperty(_class, "propTypes", {
        width: _propTypes.default.number,
        height: _propTypes.default.number
      }), _defineProperty(_class, "contextTypes", {
        glSizable: _propTypes.default.object.isRequired
      }), _defineProperty(_class, "childContextTypes", {
        glSizable: _propTypes.default.object.isRequired
      }), _class;
    };
    var _default = connectSize;
    exports.default = _default;
  }
});

// node_modules/gl-shader/lib/reflect.js
var require_reflect = __commonJS({
  "node_modules/gl-shader/lib/reflect.js"(exports, module) {
    "use strict";
    module.exports = makeReflectTypes;
    function makeReflectTypes(uniforms, useIndex) {
      var obj = {};
      for (var i = 0; i < uniforms.length; ++i) {
        var n = uniforms[i].name;
        var parts = n.split(".");
        var o = obj;
        for (var j = 0; j < parts.length; ++j) {
          var x = parts[j].split("[");
          if (x.length > 1) {
            if (!(x[0] in o)) {
              o[x[0]] = [];
            }
            o = o[x[0]];
            for (var k = 1; k < x.length; ++k) {
              var y = parseInt(x[k]);
              if (k < x.length - 1 || j < parts.length - 1) {
                if (!(y in o)) {
                  if (k < x.length - 1) {
                    o[y] = [];
                  } else {
                    o[y] = {};
                  }
                }
                o = o[y];
              } else {
                if (useIndex) {
                  o[y] = i;
                } else {
                  o[y] = uniforms[i].type;
                }
              }
            }
          } else if (j < parts.length - 1) {
            if (!(x[0] in o)) {
              o[x[0]] = {};
            }
            o = o[x[0]];
          } else {
            if (useIndex) {
              o[x[0]] = i;
            } else {
              o[x[0]] = uniforms[i].type;
            }
          }
        }
      }
      return obj;
    }
  }
});

// node_modules/gl-shader/lib/GLError.js
var require_GLError = __commonJS({
  "node_modules/gl-shader/lib/GLError.js"(exports, module) {
    function GLError(rawError, shortMessage, longMessage) {
      this.shortMessage = shortMessage || "";
      this.longMessage = longMessage || "";
      this.rawError = rawError || "";
      this.message = "gl-shader: " + (shortMessage || rawError || "") + (longMessage ? "\n" + longMessage : "");
      this.stack = new Error().stack;
    }
    GLError.prototype = new Error();
    GLError.prototype.name = "GLError";
    GLError.prototype.constructor = GLError;
    module.exports = GLError;
  }
});

// node_modules/gl-shader/lib/create-uniforms.js
var require_create_uniforms = __commonJS({
  "node_modules/gl-shader/lib/create-uniforms.js"(exports, module) {
    "use strict";
    var coallesceUniforms = require_reflect();
    var GLError = require_GLError();
    module.exports = createUniformWrapper;
    function identity(x) {
      return function() {
        return x;
      };
    }
    function makeVector(length, fill) {
      var result = new Array(length);
      for (var i = 0; i < length; ++i) {
        result[i] = fill;
      }
      return result;
    }
    function createUniformWrapper(gl, wrapper, uniforms, locations) {
      function makeGetter(idx) {
        return function(gl2, wrapper2, locations2) {
          return gl2.getUniform(wrapper2.program, locations2[idx]);
        };
      }
      function makeSetter(type) {
        return function updateProperty(obj) {
          var indices = enumerateIndices("", type);
          for (var i = 0; i < indices.length; ++i) {
            var item = indices[i];
            var path = item[0];
            var idx = item[1];
            if (locations[idx]) {
              var objPath = obj;
              if (typeof path === "string" && (path.indexOf(".") === 0 || path.indexOf("[") === 0)) {
                var key = path;
                if (path.indexOf(".") === 0) {
                  key = path.slice(1);
                }
                if (key.indexOf("]") === key.length - 1) {
                  var j = key.indexOf("[");
                  var k1 = key.slice(0, j);
                  var k2 = key.slice(j + 1, key.length - 1);
                  objPath = k1 ? obj[k1][k2] : obj[k2];
                } else {
                  objPath = obj[key];
                }
              }
              var t = uniforms[idx].type;
              var d;
              switch (t) {
                case "bool":
                case "int":
                case "sampler2D":
                case "samplerCube":
                  gl.uniform1i(locations[idx], objPath);
                  break;
                case "float":
                  gl.uniform1f(locations[idx], objPath);
                  break;
                default:
                  var vidx = t.indexOf("vec");
                  if (0 <= vidx && vidx <= 1 && t.length === 4 + vidx) {
                    d = t.charCodeAt(t.length - 1) - 48;
                    if (d < 2 || d > 4) {
                      throw new GLError("", "Invalid data type");
                    }
                    switch (t.charAt(0)) {
                      case "b":
                      case "i":
                        gl["uniform" + d + "iv"](locations[idx], objPath);
                        break;
                      case "v":
                        gl["uniform" + d + "fv"](locations[idx], objPath);
                        break;
                      default:
                        throw new GLError("", "Unrecognized data type for vector " + name + ": " + t);
                    }
                  } else if (t.indexOf("mat") === 0 && t.length === 4) {
                    d = t.charCodeAt(t.length - 1) - 48;
                    if (d < 2 || d > 4) {
                      throw new GLError("", "Invalid uniform dimension type for matrix " + name + ": " + t);
                    }
                    gl["uniformMatrix" + d + "fv"](locations[idx], false, objPath);
                    break;
                  } else {
                    throw new GLError("", "Unknown uniform data type for " + name + ": " + t);
                  }
              }
            }
          }
        };
      }
      function enumerateIndices(prefix, type) {
        if (typeof type !== "object") {
          return [[prefix, type]];
        }
        var indices = [];
        for (var id in type) {
          var prop = type[id];
          var tprefix = prefix;
          if (parseInt(id) + "" === id) {
            tprefix += "[" + id + "]";
          } else {
            tprefix += "." + id;
          }
          if (typeof prop === "object") {
            indices.push.apply(indices, enumerateIndices(tprefix, prop));
          } else {
            indices.push([tprefix, prop]);
          }
        }
        return indices;
      }
      function defaultValue(type) {
        switch (type) {
          case "bool":
            return false;
          case "int":
          case "sampler2D":
          case "samplerCube":
            return 0;
          case "float":
            return 0;
          default:
            var vidx = type.indexOf("vec");
            if (0 <= vidx && vidx <= 1 && type.length === 4 + vidx) {
              var d = type.charCodeAt(type.length - 1) - 48;
              if (d < 2 || d > 4) {
                throw new GLError("", "Invalid data type");
              }
              if (type.charAt(0) === "b") {
                return makeVector(d, false);
              }
              return makeVector(d, 0);
            } else if (type.indexOf("mat") === 0 && type.length === 4) {
              var d = type.charCodeAt(type.length - 1) - 48;
              if (d < 2 || d > 4) {
                throw new GLError("", "Invalid uniform dimension type for matrix " + name + ": " + type);
              }
              return makeVector(d * d, 0);
            } else {
              throw new GLError("", "Unknown uniform data type for " + name + ": " + type);
            }
        }
      }
      function storeProperty(obj, prop, type) {
        if (typeof type === "object") {
          var child = processObject(type);
          Object.defineProperty(obj, prop, {
            get: identity(child),
            set: makeSetter(type),
            enumerable: true,
            configurable: false
          });
        } else {
          if (locations[type]) {
            Object.defineProperty(obj, prop, {
              get: makeGetter(type),
              set: makeSetter(type),
              enumerable: true,
              configurable: false
            });
          } else {
            obj[prop] = defaultValue(uniforms[type].type);
          }
        }
      }
      function processObject(obj) {
        var result;
        if (Array.isArray(obj)) {
          result = new Array(obj.length);
          for (var i = 0; i < obj.length; ++i) {
            storeProperty(result, i, obj[i]);
          }
        } else {
          result = {};
          for (var id in obj) {
            storeProperty(result, id, obj[id]);
          }
        }
        return result;
      }
      var coallesced = coallesceUniforms(uniforms, true);
      return {
        get: identity(processObject(coallesced)),
        set: makeSetter(coallesced),
        enumerable: true,
        configurable: true
      };
    }
  }
});

// node_modules/gl-shader/lib/create-attributes.js
var require_create_attributes = __commonJS({
  "node_modules/gl-shader/lib/create-attributes.js"(exports, module) {
    "use strict";
    module.exports = createAttributeWrapper;
    var GLError = require_GLError();
    function ShaderAttribute(gl, wrapper, index, locations, dimension, constFunc) {
      this._gl = gl;
      this._wrapper = wrapper;
      this._index = index;
      this._locations = locations;
      this._dimension = dimension;
      this._constFunc = constFunc;
    }
    var proto = ShaderAttribute.prototype;
    proto.pointer = function setAttribPointer(type, normalized, stride, offset) {
      var self = this;
      var gl = self._gl;
      var location = self._locations[self._index];
      gl.vertexAttribPointer(
        location,
        self._dimension,
        type || gl.FLOAT,
        !!normalized,
        stride || 0,
        offset || 0
      );
      gl.enableVertexAttribArray(location);
    };
    proto.set = function(x0, x1, x2, x3) {
      return this._constFunc(this._locations[this._index], x0, x1, x2, x3);
    };
    Object.defineProperty(proto, "location", {
      get: function() {
        return this._locations[this._index];
      },
      set: function(v) {
        if (v !== this._locations[this._index]) {
          this._locations[this._index] = v | 0;
          this._wrapper.program = null;
        }
        return v | 0;
      }
    });
    var allFns = [
      function(gl, v, x0) {
        if (x0.length === void 0) {
          return gl.vertexAttrib1f(v, x0);
        } else {
          return gl.vertexAttrib1fv(v, x0);
        }
      },
      function(gl, v, x0, x1) {
        if (x0.length === void 0) {
          return gl.vertexAttrib2f(v, x0, x1);
        } else {
          return gl.vertexAttrib2fv(v, x0);
        }
      },
      function(gl, v, x0, x1, x2) {
        if (x0.length === void 0) {
          return gl.vertexAttrib3f(v, x0, x1, x2);
        } else {
          return gl.vertexAttrib3fv(v, x0);
        }
      },
      function(gl, v, x0, x1, x2, x3) {
        if (x0.length === void 0) {
          return gl.vertexAttrib4f(v, x0, x1, x2, x3);
        } else {
          return gl.vertexAttrib4fv(v, x0);
        }
      }
    ];
    function addVectorAttribute(gl, wrapper, index, locations, dimension, obj, name2) {
      var constFunc = allFns[dimension];
      var attr = new ShaderAttribute(
        gl,
        wrapper,
        index,
        locations,
        dimension,
        constFunc
      );
      Object.defineProperty(obj, name2, {
        set: function(x) {
          gl.disableVertexAttribArray(locations[index]);
          constFunc(gl, locations[index], x);
          return x;
        },
        get: function() {
          return attr;
        },
        enumerable: true
      });
    }
    function addMatrixAttribute(gl, wrapper, index, locations, dimension, obj, name2) {
      var parts = new Array(dimension);
      var attrs = new Array(dimension);
      for (var i = 0; i < dimension; ++i) {
        addVectorAttribute(
          gl,
          wrapper,
          index[i],
          locations,
          dimension,
          parts,
          i
        );
        attrs[i] = parts[i];
      }
      Object.defineProperty(parts, "location", {
        set: function(v) {
          if (Array.isArray(v)) {
            for (var i2 = 0; i2 < dimension; ++i2) {
              attrs[i2].location = v[i2];
            }
          } else {
            for (var i2 = 0; i2 < dimension; ++i2) {
              attrs[i2].location = v + i2;
            }
          }
          return v;
        },
        get: function() {
          var result = new Array(dimension);
          for (var i2 = 0; i2 < dimension; ++i2) {
            result[i2] = locations[index[i2]];
          }
          return result;
        },
        enumerable: true
      });
      parts.pointer = function(type, normalized, stride, offset) {
        type = type || gl.FLOAT;
        normalized = !!normalized;
        stride = stride || dimension * dimension;
        offset = offset || 0;
        for (var i2 = 0; i2 < dimension; ++i2) {
          var location = locations[index[i2]];
          gl.vertexAttribPointer(
            location,
            dimension,
            type,
            normalized,
            stride,
            offset + i2 * dimension
          );
          gl.enableVertexAttribArray(location);
        }
      };
      var scratch = new Array(dimension);
      var vertexAttrib = gl["vertexAttrib" + dimension + "fv"];
      Object.defineProperty(obj, name2, {
        set: function(x) {
          for (var i2 = 0; i2 < dimension; ++i2) {
            var loc = locations[index[i2]];
            gl.disableVertexAttribArray(loc);
            if (Array.isArray(x[0])) {
              vertexAttrib.call(gl, loc, x[i2]);
            } else {
              for (var j = 0; j < dimension; ++j) {
                scratch[j] = x[dimension * i2 + j];
              }
              vertexAttrib.call(gl, loc, scratch);
            }
          }
          return x;
        },
        get: function() {
          return parts;
        },
        enumerable: true
      });
    }
    function createAttributeWrapper(gl, wrapper, attributes, locations) {
      var obj = {};
      for (var i = 0, n = attributes.length; i < n; ++i) {
        var a = attributes[i];
        var name2 = a.name;
        var type = a.type;
        var locs = a.locations;
        switch (type) {
          case "bool":
          case "int":
          case "float":
            addVectorAttribute(
              gl,
              wrapper,
              locs[0],
              locations,
              1,
              obj,
              name2
            );
            break;
          default:
            if (type.indexOf("vec") >= 0) {
              var d = type.charCodeAt(type.length - 1) - 48;
              if (d < 2 || d > 4) {
                throw new GLError("", "Invalid data type for attribute " + name2 + ": " + type);
              }
              addVectorAttribute(
                gl,
                wrapper,
                locs[0],
                locations,
                d,
                obj,
                name2
              );
            } else if (type.indexOf("mat") >= 0) {
              var d = type.charCodeAt(type.length - 1) - 48;
              if (d < 2 || d > 4) {
                throw new GLError("", "Invalid data type for attribute " + name2 + ": " + type);
              }
              addMatrixAttribute(
                gl,
                wrapper,
                locs,
                locations,
                d,
                obj,
                name2
              );
            } else {
              throw new GLError("", "Unknown data type for attribute " + name2 + ": " + type);
            }
            break;
        }
      }
      return obj;
    }
  }
});

// node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/sprintf-js/src/sprintf.js"(exports) {
    !function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign;
        for (i = 0; i < tree_length; i++) {
          if (typeof parse_tree[i] === "string") {
            output += parse_tree[i];
          } else if (typeof parse_tree[i] === "object") {
            ph = parse_tree[i];
            if (ph.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                }
                arg = arg[ph.keys[k]];
              }
            } else if (ph.param_no) {
              arg = argv[ph.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph.type)) {
              is_positive = arg >= 0;
            }
            switch (ph.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                break;
              case "e":
                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph.type)) {
              output += arg;
            } else {
              if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                sign = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign = "";
              }
              pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
              pad_length = ph.width - (sign + arg).length;
              pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph.align ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
            }
          }
        }
        return output;
      }
      var sprintf_cache = /* @__PURE__ */ Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = re.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push(
              {
                placeholder: match[0],
                param_no: match[1],
                keys: match[2],
                sign: match[3],
                pad_char: match[4],
                align: match[5],
                width: match[6],
                precision: match[7],
                type: match[8]
              }
            );
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports !== "undefined") {
        exports["sprintf"] = sprintf;
        exports["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf,
              "vsprintf": vsprintf
            };
          });
        }
      }
    }();
  }
});

// node_modules/gl-constants/1.0/numbers.js
var require_numbers = __commonJS({
  "node_modules/gl-constants/1.0/numbers.js"(exports, module) {
    module.exports = {
      0: "NONE",
      1: "ONE",
      2: "LINE_LOOP",
      3: "LINE_STRIP",
      4: "TRIANGLES",
      5: "TRIANGLE_STRIP",
      6: "TRIANGLE_FAN",
      256: "DEPTH_BUFFER_BIT",
      512: "NEVER",
      513: "LESS",
      514: "EQUAL",
      515: "LEQUAL",
      516: "GREATER",
      517: "NOTEQUAL",
      518: "GEQUAL",
      519: "ALWAYS",
      768: "SRC_COLOR",
      769: "ONE_MINUS_SRC_COLOR",
      770: "SRC_ALPHA",
      771: "ONE_MINUS_SRC_ALPHA",
      772: "DST_ALPHA",
      773: "ONE_MINUS_DST_ALPHA",
      774: "DST_COLOR",
      775: "ONE_MINUS_DST_COLOR",
      776: "SRC_ALPHA_SATURATE",
      1024: "STENCIL_BUFFER_BIT",
      1028: "FRONT",
      1029: "BACK",
      1032: "FRONT_AND_BACK",
      1280: "INVALID_ENUM",
      1281: "INVALID_VALUE",
      1282: "INVALID_OPERATION",
      1285: "OUT_OF_MEMORY",
      1286: "INVALID_FRAMEBUFFER_OPERATION",
      2304: "CW",
      2305: "CCW",
      2849: "LINE_WIDTH",
      2884: "CULL_FACE",
      2885: "CULL_FACE_MODE",
      2886: "FRONT_FACE",
      2928: "DEPTH_RANGE",
      2929: "DEPTH_TEST",
      2930: "DEPTH_WRITEMASK",
      2931: "DEPTH_CLEAR_VALUE",
      2932: "DEPTH_FUNC",
      2960: "STENCIL_TEST",
      2961: "STENCIL_CLEAR_VALUE",
      2962: "STENCIL_FUNC",
      2963: "STENCIL_VALUE_MASK",
      2964: "STENCIL_FAIL",
      2965: "STENCIL_PASS_DEPTH_FAIL",
      2966: "STENCIL_PASS_DEPTH_PASS",
      2967: "STENCIL_REF",
      2968: "STENCIL_WRITEMASK",
      2978: "VIEWPORT",
      3024: "DITHER",
      3042: "BLEND",
      3088: "SCISSOR_BOX",
      3089: "SCISSOR_TEST",
      3106: "COLOR_CLEAR_VALUE",
      3107: "COLOR_WRITEMASK",
      3317: "UNPACK_ALIGNMENT",
      3333: "PACK_ALIGNMENT",
      3379: "MAX_TEXTURE_SIZE",
      3386: "MAX_VIEWPORT_DIMS",
      3408: "SUBPIXEL_BITS",
      3410: "RED_BITS",
      3411: "GREEN_BITS",
      3412: "BLUE_BITS",
      3413: "ALPHA_BITS",
      3414: "DEPTH_BITS",
      3415: "STENCIL_BITS",
      3553: "TEXTURE_2D",
      4352: "DONT_CARE",
      4353: "FASTEST",
      4354: "NICEST",
      5120: "BYTE",
      5121: "UNSIGNED_BYTE",
      5122: "SHORT",
      5123: "UNSIGNED_SHORT",
      5124: "INT",
      5125: "UNSIGNED_INT",
      5126: "FLOAT",
      5386: "INVERT",
      5890: "TEXTURE",
      6401: "STENCIL_INDEX",
      6402: "DEPTH_COMPONENT",
      6406: "ALPHA",
      6407: "RGB",
      6408: "RGBA",
      6409: "LUMINANCE",
      6410: "LUMINANCE_ALPHA",
      7680: "KEEP",
      7681: "REPLACE",
      7682: "INCR",
      7683: "DECR",
      7936: "VENDOR",
      7937: "RENDERER",
      7938: "VERSION",
      9728: "NEAREST",
      9729: "LINEAR",
      9984: "NEAREST_MIPMAP_NEAREST",
      9985: "LINEAR_MIPMAP_NEAREST",
      9986: "NEAREST_MIPMAP_LINEAR",
      9987: "LINEAR_MIPMAP_LINEAR",
      10240: "TEXTURE_MAG_FILTER",
      10241: "TEXTURE_MIN_FILTER",
      10242: "TEXTURE_WRAP_S",
      10243: "TEXTURE_WRAP_T",
      10497: "REPEAT",
      10752: "POLYGON_OFFSET_UNITS",
      16384: "COLOR_BUFFER_BIT",
      32769: "CONSTANT_COLOR",
      32770: "ONE_MINUS_CONSTANT_COLOR",
      32771: "CONSTANT_ALPHA",
      32772: "ONE_MINUS_CONSTANT_ALPHA",
      32773: "BLEND_COLOR",
      32774: "FUNC_ADD",
      32777: "BLEND_EQUATION_RGB",
      32778: "FUNC_SUBTRACT",
      32779: "FUNC_REVERSE_SUBTRACT",
      32819: "UNSIGNED_SHORT_4_4_4_4",
      32820: "UNSIGNED_SHORT_5_5_5_1",
      32823: "POLYGON_OFFSET_FILL",
      32824: "POLYGON_OFFSET_FACTOR",
      32854: "RGBA4",
      32855: "RGB5_A1",
      32873: "TEXTURE_BINDING_2D",
      32926: "SAMPLE_ALPHA_TO_COVERAGE",
      32928: "SAMPLE_COVERAGE",
      32936: "SAMPLE_BUFFERS",
      32937: "SAMPLES",
      32938: "SAMPLE_COVERAGE_VALUE",
      32939: "SAMPLE_COVERAGE_INVERT",
      32968: "BLEND_DST_RGB",
      32969: "BLEND_SRC_RGB",
      32970: "BLEND_DST_ALPHA",
      32971: "BLEND_SRC_ALPHA",
      33071: "CLAMP_TO_EDGE",
      33170: "GENERATE_MIPMAP_HINT",
      33189: "DEPTH_COMPONENT16",
      33306: "DEPTH_STENCIL_ATTACHMENT",
      33635: "UNSIGNED_SHORT_5_6_5",
      33648: "MIRRORED_REPEAT",
      33901: "ALIASED_POINT_SIZE_RANGE",
      33902: "ALIASED_LINE_WIDTH_RANGE",
      33984: "TEXTURE0",
      33985: "TEXTURE1",
      33986: "TEXTURE2",
      33987: "TEXTURE3",
      33988: "TEXTURE4",
      33989: "TEXTURE5",
      33990: "TEXTURE6",
      33991: "TEXTURE7",
      33992: "TEXTURE8",
      33993: "TEXTURE9",
      33994: "TEXTURE10",
      33995: "TEXTURE11",
      33996: "TEXTURE12",
      33997: "TEXTURE13",
      33998: "TEXTURE14",
      33999: "TEXTURE15",
      34e3: "TEXTURE16",
      34001: "TEXTURE17",
      34002: "TEXTURE18",
      34003: "TEXTURE19",
      34004: "TEXTURE20",
      34005: "TEXTURE21",
      34006: "TEXTURE22",
      34007: "TEXTURE23",
      34008: "TEXTURE24",
      34009: "TEXTURE25",
      34010: "TEXTURE26",
      34011: "TEXTURE27",
      34012: "TEXTURE28",
      34013: "TEXTURE29",
      34014: "TEXTURE30",
      34015: "TEXTURE31",
      34016: "ACTIVE_TEXTURE",
      34024: "MAX_RENDERBUFFER_SIZE",
      34041: "DEPTH_STENCIL",
      34055: "INCR_WRAP",
      34056: "DECR_WRAP",
      34067: "TEXTURE_CUBE_MAP",
      34068: "TEXTURE_BINDING_CUBE_MAP",
      34069: "TEXTURE_CUBE_MAP_POSITIVE_X",
      34070: "TEXTURE_CUBE_MAP_NEGATIVE_X",
      34071: "TEXTURE_CUBE_MAP_POSITIVE_Y",
      34072: "TEXTURE_CUBE_MAP_NEGATIVE_Y",
      34073: "TEXTURE_CUBE_MAP_POSITIVE_Z",
      34074: "TEXTURE_CUBE_MAP_NEGATIVE_Z",
      34076: "MAX_CUBE_MAP_TEXTURE_SIZE",
      34338: "VERTEX_ATTRIB_ARRAY_ENABLED",
      34339: "VERTEX_ATTRIB_ARRAY_SIZE",
      34340: "VERTEX_ATTRIB_ARRAY_STRIDE",
      34341: "VERTEX_ATTRIB_ARRAY_TYPE",
      34342: "CURRENT_VERTEX_ATTRIB",
      34373: "VERTEX_ATTRIB_ARRAY_POINTER",
      34466: "NUM_COMPRESSED_TEXTURE_FORMATS",
      34467: "COMPRESSED_TEXTURE_FORMATS",
      34660: "BUFFER_SIZE",
      34661: "BUFFER_USAGE",
      34816: "STENCIL_BACK_FUNC",
      34817: "STENCIL_BACK_FAIL",
      34818: "STENCIL_BACK_PASS_DEPTH_FAIL",
      34819: "STENCIL_BACK_PASS_DEPTH_PASS",
      34877: "BLEND_EQUATION_ALPHA",
      34921: "MAX_VERTEX_ATTRIBS",
      34922: "VERTEX_ATTRIB_ARRAY_NORMALIZED",
      34930: "MAX_TEXTURE_IMAGE_UNITS",
      34962: "ARRAY_BUFFER",
      34963: "ELEMENT_ARRAY_BUFFER",
      34964: "ARRAY_BUFFER_BINDING",
      34965: "ELEMENT_ARRAY_BUFFER_BINDING",
      34975: "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",
      35040: "STREAM_DRAW",
      35044: "STATIC_DRAW",
      35048: "DYNAMIC_DRAW",
      35632: "FRAGMENT_SHADER",
      35633: "VERTEX_SHADER",
      35660: "MAX_VERTEX_TEXTURE_IMAGE_UNITS",
      35661: "MAX_COMBINED_TEXTURE_IMAGE_UNITS",
      35663: "SHADER_TYPE",
      35664: "FLOAT_VEC2",
      35665: "FLOAT_VEC3",
      35666: "FLOAT_VEC4",
      35667: "INT_VEC2",
      35668: "INT_VEC3",
      35669: "INT_VEC4",
      35670: "BOOL",
      35671: "BOOL_VEC2",
      35672: "BOOL_VEC3",
      35673: "BOOL_VEC4",
      35674: "FLOAT_MAT2",
      35675: "FLOAT_MAT3",
      35676: "FLOAT_MAT4",
      35678: "SAMPLER_2D",
      35680: "SAMPLER_CUBE",
      35712: "DELETE_STATUS",
      35713: "COMPILE_STATUS",
      35714: "LINK_STATUS",
      35715: "VALIDATE_STATUS",
      35716: "INFO_LOG_LENGTH",
      35717: "ATTACHED_SHADERS",
      35718: "ACTIVE_UNIFORMS",
      35719: "ACTIVE_UNIFORM_MAX_LENGTH",
      35720: "SHADER_SOURCE_LENGTH",
      35721: "ACTIVE_ATTRIBUTES",
      35722: "ACTIVE_ATTRIBUTE_MAX_LENGTH",
      35724: "SHADING_LANGUAGE_VERSION",
      35725: "CURRENT_PROGRAM",
      36003: "STENCIL_BACK_REF",
      36004: "STENCIL_BACK_VALUE_MASK",
      36005: "STENCIL_BACK_WRITEMASK",
      36006: "FRAMEBUFFER_BINDING",
      36007: "RENDERBUFFER_BINDING",
      36048: "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",
      36049: "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",
      36050: "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",
      36051: "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",
      36053: "FRAMEBUFFER_COMPLETE",
      36054: "FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
      36055: "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
      36057: "FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
      36061: "FRAMEBUFFER_UNSUPPORTED",
      36064: "COLOR_ATTACHMENT0",
      36096: "DEPTH_ATTACHMENT",
      36128: "STENCIL_ATTACHMENT",
      36160: "FRAMEBUFFER",
      36161: "RENDERBUFFER",
      36162: "RENDERBUFFER_WIDTH",
      36163: "RENDERBUFFER_HEIGHT",
      36164: "RENDERBUFFER_INTERNAL_FORMAT",
      36168: "STENCIL_INDEX8",
      36176: "RENDERBUFFER_RED_SIZE",
      36177: "RENDERBUFFER_GREEN_SIZE",
      36178: "RENDERBUFFER_BLUE_SIZE",
      36179: "RENDERBUFFER_ALPHA_SIZE",
      36180: "RENDERBUFFER_DEPTH_SIZE",
      36181: "RENDERBUFFER_STENCIL_SIZE",
      36194: "RGB565",
      36336: "LOW_FLOAT",
      36337: "MEDIUM_FLOAT",
      36338: "HIGH_FLOAT",
      36339: "LOW_INT",
      36340: "MEDIUM_INT",
      36341: "HIGH_INT",
      36346: "SHADER_COMPILER",
      36347: "MAX_VERTEX_UNIFORM_VECTORS",
      36348: "MAX_VARYING_VECTORS",
      36349: "MAX_FRAGMENT_UNIFORM_VECTORS",
      37440: "UNPACK_FLIP_Y_WEBGL",
      37441: "UNPACK_PREMULTIPLY_ALPHA_WEBGL",
      37442: "CONTEXT_LOST_WEBGL",
      37443: "UNPACK_COLORSPACE_CONVERSION_WEBGL",
      37444: "BROWSER_DEFAULT_WEBGL"
    };
  }
});

// node_modules/gl-constants/lookup.js
var require_lookup = __commonJS({
  "node_modules/gl-constants/lookup.js"(exports, module) {
    var gl10 = require_numbers();
    module.exports = function lookupConstant(number) {
      return gl10[number];
    };
  }
});

// node_modules/glsl-tokenizer/lib/literals.js
var require_literals = __commonJS({
  "node_modules/glsl-tokenizer/lib/literals.js"(exports, module) {
    module.exports = [
      // current
      "precision",
      "highp",
      "mediump",
      "lowp",
      "attribute",
      "const",
      "uniform",
      "varying",
      "break",
      "continue",
      "do",
      "for",
      "while",
      "if",
      "else",
      "in",
      "out",
      "inout",
      "float",
      "int",
      "uint",
      "void",
      "bool",
      "true",
      "false",
      "discard",
      "return",
      "mat2",
      "mat3",
      "mat4",
      "vec2",
      "vec3",
      "vec4",
      "ivec2",
      "ivec3",
      "ivec4",
      "bvec2",
      "bvec3",
      "bvec4",
      "sampler1D",
      "sampler2D",
      "sampler3D",
      "samplerCube",
      "sampler1DShadow",
      "sampler2DShadow",
      "struct",
      "asm",
      "class",
      "union",
      "enum",
      "typedef",
      "template",
      "this",
      "packed",
      "goto",
      "switch",
      "default",
      "inline",
      "noinline",
      "volatile",
      "public",
      "static",
      "extern",
      "external",
      "interface",
      "long",
      "short",
      "double",
      "half",
      "fixed",
      "unsigned",
      "input",
      "output",
      "hvec2",
      "hvec3",
      "hvec4",
      "dvec2",
      "dvec3",
      "dvec4",
      "fvec2",
      "fvec3",
      "fvec4",
      "sampler2DRect",
      "sampler3DRect",
      "sampler2DRectShadow",
      "sizeof",
      "cast",
      "namespace",
      "using"
    ];
  }
});

// node_modules/glsl-tokenizer/lib/operators.js
var require_operators = __commonJS({
  "node_modules/glsl-tokenizer/lib/operators.js"(exports, module) {
    module.exports = [
      "<<=",
      ">>=",
      "++",
      "--",
      "<<",
      ">>",
      "<=",
      ">=",
      "==",
      "!=",
      "&&",
      "||",
      "+=",
      "-=",
      "*=",
      "/=",
      "%=",
      "&=",
      "^^",
      "^=",
      "|=",
      "(",
      ")",
      "[",
      "]",
      ".",
      "!",
      "~",
      "*",
      "/",
      "%",
      "+",
      "-",
      "<",
      ">",
      "&",
      "^",
      "|",
      "?",
      ":",
      "=",
      ",",
      ";",
      "{",
      "}"
    ];
  }
});

// node_modules/glsl-tokenizer/lib/builtins.js
var require_builtins = __commonJS({
  "node_modules/glsl-tokenizer/lib/builtins.js"(exports, module) {
    module.exports = [
      // Keep this list sorted
      "abs",
      "acos",
      "all",
      "any",
      "asin",
      "atan",
      "ceil",
      "clamp",
      "cos",
      "cross",
      "dFdx",
      "dFdy",
      "degrees",
      "distance",
      "dot",
      "equal",
      "exp",
      "exp2",
      "faceforward",
      "floor",
      "fract",
      "gl_BackColor",
      "gl_BackLightModelProduct",
      "gl_BackLightProduct",
      "gl_BackMaterial",
      "gl_BackSecondaryColor",
      "gl_ClipPlane",
      "gl_ClipVertex",
      "gl_Color",
      "gl_DepthRange",
      "gl_DepthRangeParameters",
      "gl_EyePlaneQ",
      "gl_EyePlaneR",
      "gl_EyePlaneS",
      "gl_EyePlaneT",
      "gl_Fog",
      "gl_FogCoord",
      "gl_FogFragCoord",
      "gl_FogParameters",
      "gl_FragColor",
      "gl_FragCoord",
      "gl_FragData",
      "gl_FragDepth",
      "gl_FragDepthEXT",
      "gl_FrontColor",
      "gl_FrontFacing",
      "gl_FrontLightModelProduct",
      "gl_FrontLightProduct",
      "gl_FrontMaterial",
      "gl_FrontSecondaryColor",
      "gl_LightModel",
      "gl_LightModelParameters",
      "gl_LightModelProducts",
      "gl_LightProducts",
      "gl_LightSource",
      "gl_LightSourceParameters",
      "gl_MaterialParameters",
      "gl_MaxClipPlanes",
      "gl_MaxCombinedTextureImageUnits",
      "gl_MaxDrawBuffers",
      "gl_MaxFragmentUniformComponents",
      "gl_MaxLights",
      "gl_MaxTextureCoords",
      "gl_MaxTextureImageUnits",
      "gl_MaxTextureUnits",
      "gl_MaxVaryingFloats",
      "gl_MaxVertexAttribs",
      "gl_MaxVertexTextureImageUnits",
      "gl_MaxVertexUniformComponents",
      "gl_ModelViewMatrix",
      "gl_ModelViewMatrixInverse",
      "gl_ModelViewMatrixInverseTranspose",
      "gl_ModelViewMatrixTranspose",
      "gl_ModelViewProjectionMatrix",
      "gl_ModelViewProjectionMatrixInverse",
      "gl_ModelViewProjectionMatrixInverseTranspose",
      "gl_ModelViewProjectionMatrixTranspose",
      "gl_MultiTexCoord0",
      "gl_MultiTexCoord1",
      "gl_MultiTexCoord2",
      "gl_MultiTexCoord3",
      "gl_MultiTexCoord4",
      "gl_MultiTexCoord5",
      "gl_MultiTexCoord6",
      "gl_MultiTexCoord7",
      "gl_Normal",
      "gl_NormalMatrix",
      "gl_NormalScale",
      "gl_ObjectPlaneQ",
      "gl_ObjectPlaneR",
      "gl_ObjectPlaneS",
      "gl_ObjectPlaneT",
      "gl_Point",
      "gl_PointCoord",
      "gl_PointParameters",
      "gl_PointSize",
      "gl_Position",
      "gl_ProjectionMatrix",
      "gl_ProjectionMatrixInverse",
      "gl_ProjectionMatrixInverseTranspose",
      "gl_ProjectionMatrixTranspose",
      "gl_SecondaryColor",
      "gl_TexCoord",
      "gl_TextureEnvColor",
      "gl_TextureMatrix",
      "gl_TextureMatrixInverse",
      "gl_TextureMatrixInverseTranspose",
      "gl_TextureMatrixTranspose",
      "gl_Vertex",
      "greaterThan",
      "greaterThanEqual",
      "inversesqrt",
      "length",
      "lessThan",
      "lessThanEqual",
      "log",
      "log2",
      "matrixCompMult",
      "max",
      "min",
      "mix",
      "mod",
      "normalize",
      "not",
      "notEqual",
      "pow",
      "radians",
      "reflect",
      "refract",
      "sign",
      "sin",
      "smoothstep",
      "sqrt",
      "step",
      "tan",
      "texture2D",
      "texture2DLod",
      "texture2DProj",
      "texture2DProjLod",
      "textureCube",
      "textureCubeLod",
      "texture2DLodEXT",
      "texture2DProjLodEXT",
      "textureCubeLodEXT",
      "texture2DGradEXT",
      "texture2DProjGradEXT",
      "textureCubeGradEXT"
    ];
  }
});

// node_modules/glsl-tokenizer/lib/literals-300es.js
var require_literals_300es = __commonJS({
  "node_modules/glsl-tokenizer/lib/literals-300es.js"(exports, module) {
    var v100 = require_literals();
    module.exports = v100.slice().concat([
      "layout",
      "centroid",
      "smooth",
      "case",
      "mat2x2",
      "mat2x3",
      "mat2x4",
      "mat3x2",
      "mat3x3",
      "mat3x4",
      "mat4x2",
      "mat4x3",
      "mat4x4",
      "uvec2",
      "uvec3",
      "uvec4",
      "samplerCubeShadow",
      "sampler2DArray",
      "sampler2DArrayShadow",
      "isampler2D",
      "isampler3D",
      "isamplerCube",
      "isampler2DArray",
      "usampler2D",
      "usampler3D",
      "usamplerCube",
      "usampler2DArray",
      "coherent",
      "restrict",
      "readonly",
      "writeonly",
      "resource",
      "atomic_uint",
      "noperspective",
      "patch",
      "sample",
      "subroutine",
      "common",
      "partition",
      "active",
      "filter",
      "image1D",
      "image2D",
      "image3D",
      "imageCube",
      "iimage1D",
      "iimage2D",
      "iimage3D",
      "iimageCube",
      "uimage1D",
      "uimage2D",
      "uimage3D",
      "uimageCube",
      "image1DArray",
      "image2DArray",
      "iimage1DArray",
      "iimage2DArray",
      "uimage1DArray",
      "uimage2DArray",
      "image1DShadow",
      "image2DShadow",
      "image1DArrayShadow",
      "image2DArrayShadow",
      "imageBuffer",
      "iimageBuffer",
      "uimageBuffer",
      "sampler1DArray",
      "sampler1DArrayShadow",
      "isampler1D",
      "isampler1DArray",
      "usampler1D",
      "usampler1DArray",
      "isampler2DRect",
      "usampler2DRect",
      "samplerBuffer",
      "isamplerBuffer",
      "usamplerBuffer",
      "sampler2DMS",
      "isampler2DMS",
      "usampler2DMS",
      "sampler2DMSArray",
      "isampler2DMSArray",
      "usampler2DMSArray"
    ]);
  }
});

// node_modules/glsl-tokenizer/lib/builtins-300es.js
var require_builtins_300es = __commonJS({
  "node_modules/glsl-tokenizer/lib/builtins-300es.js"(exports, module) {
    var v100 = require_builtins();
    v100 = v100.slice().filter(function(b) {
      return !/^(gl\_|texture)/.test(b);
    });
    module.exports = v100.concat([
      // the updated gl_ constants
      "gl_VertexID",
      "gl_InstanceID",
      "gl_Position",
      "gl_PointSize",
      "gl_FragCoord",
      "gl_FrontFacing",
      "gl_FragDepth",
      "gl_PointCoord",
      "gl_MaxVertexAttribs",
      "gl_MaxVertexUniformVectors",
      "gl_MaxVertexOutputVectors",
      "gl_MaxFragmentInputVectors",
      "gl_MaxVertexTextureImageUnits",
      "gl_MaxCombinedTextureImageUnits",
      "gl_MaxTextureImageUnits",
      "gl_MaxFragmentUniformVectors",
      "gl_MaxDrawBuffers",
      "gl_MinProgramTexelOffset",
      "gl_MaxProgramTexelOffset",
      "gl_DepthRangeParameters",
      "gl_DepthRange",
      "trunc",
      "round",
      "roundEven",
      "isnan",
      "isinf",
      "floatBitsToInt",
      "floatBitsToUint",
      "intBitsToFloat",
      "uintBitsToFloat",
      "packSnorm2x16",
      "unpackSnorm2x16",
      "packUnorm2x16",
      "unpackUnorm2x16",
      "packHalf2x16",
      "unpackHalf2x16",
      "outerProduct",
      "transpose",
      "determinant",
      "inverse",
      "texture",
      "textureSize",
      "textureProj",
      "textureLod",
      "textureOffset",
      "texelFetch",
      "texelFetchOffset",
      "textureProjOffset",
      "textureLodOffset",
      "textureProjLod",
      "textureProjLodOffset",
      "textureGrad",
      "textureGradOffset",
      "textureProjGrad",
      "textureProjGradOffset"
    ]);
  }
});

// node_modules/glsl-tokenizer/index.js
var require_glsl_tokenizer = __commonJS({
  "node_modules/glsl-tokenizer/index.js"(exports, module) {
    module.exports = tokenize;
    var literals100 = require_literals();
    var operators = require_operators();
    var builtins100 = require_builtins();
    var literals300es = require_literals_300es();
    var builtins300es = require_builtins_300es();
    var NORMAL = 999;
    var TOKEN = 9999;
    var BLOCK_COMMENT = 0;
    var LINE_COMMENT = 1;
    var PREPROCESSOR = 2;
    var OPERATOR = 3;
    var INTEGER = 4;
    var FLOAT = 5;
    var IDENT = 6;
    var BUILTIN = 7;
    var KEYWORD = 8;
    var WHITESPACE = 9;
    var EOF = 10;
    var HEX = 11;
    var map = [
      "block-comment",
      "line-comment",
      "preprocessor",
      "operator",
      "integer",
      "float",
      "ident",
      "builtin",
      "keyword",
      "whitespace",
      "eof",
      "integer"
    ];
    function tokenize(opt) {
      var i = 0, total = 0, mode = NORMAL, c, last, content = [], tokens = [], token_idx = 0, token_offs = 0, line = 1, col = 0, start = 0, isnum = false, isoperator = false, input = "", len;
      opt = opt || {};
      var allBuiltins = builtins100;
      var allLiterals = literals100;
      if (opt.version === "300 es") {
        allBuiltins = builtins300es;
        allLiterals = literals300es;
      }
      var builtinsDict = {}, literalsDict = {};
      for (var i = 0; i < allBuiltins.length; i++) {
        builtinsDict[allBuiltins[i]] = true;
      }
      for (var i = 0; i < allLiterals.length; i++) {
        literalsDict[allLiterals[i]] = true;
      }
      return function(data) {
        tokens = [];
        if (data !== null)
          return write(data);
        return end();
      };
      function token(data) {
        if (data.length) {
          tokens.push({
            type: map[mode],
            data,
            position: start,
            line,
            column: col
          });
        }
      }
      function write(chunk) {
        i = 0;
        if (chunk.toString)
          chunk = chunk.toString();
        input += chunk.replace(/\r\n/g, "\n");
        len = input.length;
        var last2;
        while (c = input[i], i < len) {
          last2 = i;
          switch (mode) {
            case BLOCK_COMMENT:
              i = block_comment();
              break;
            case LINE_COMMENT:
              i = line_comment();
              break;
            case PREPROCESSOR:
              i = preprocessor();
              break;
            case OPERATOR:
              i = operator();
              break;
            case INTEGER:
              i = integer();
              break;
            case HEX:
              i = hex();
              break;
            case FLOAT:
              i = decimal();
              break;
            case TOKEN:
              i = readtoken();
              break;
            case WHITESPACE:
              i = whitespace();
              break;
            case NORMAL:
              i = normal();
              break;
          }
          if (last2 !== i) {
            switch (input[last2]) {
              case "\n":
                col = 0;
                ++line;
                break;
              default:
                ++col;
                break;
            }
          }
        }
        total += i;
        input = input.slice(i);
        return tokens;
      }
      function end(chunk) {
        if (content.length) {
          token(content.join(""));
        }
        mode = EOF;
        token("(eof)");
        return tokens;
      }
      function normal() {
        content = content.length ? [] : content;
        if (last === "/" && c === "*") {
          start = total + i - 1;
          mode = BLOCK_COMMENT;
          last = c;
          return i + 1;
        }
        if (last === "/" && c === "/") {
          start = total + i - 1;
          mode = LINE_COMMENT;
          last = c;
          return i + 1;
        }
        if (c === "#") {
          mode = PREPROCESSOR;
          start = total + i;
          return i;
        }
        if (/\s/.test(c)) {
          mode = WHITESPACE;
          start = total + i;
          return i;
        }
        isnum = /\d/.test(c);
        isoperator = /[^\w_]/.test(c);
        start = total + i;
        mode = isnum ? INTEGER : isoperator ? OPERATOR : TOKEN;
        return i;
      }
      function whitespace() {
        if (/[^\s]/g.test(c)) {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function preprocessor() {
        if ((c === "\r" || c === "\n") && last !== "\\") {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function line_comment() {
        return preprocessor();
      }
      function block_comment() {
        if (c === "/" && last === "*") {
          content.push(c);
          token(content.join(""));
          mode = NORMAL;
          return i + 1;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function operator() {
        if (last === "." && /\d/.test(c)) {
          mode = FLOAT;
          return i;
        }
        if (last === "/" && c === "*") {
          mode = BLOCK_COMMENT;
          return i;
        }
        if (last === "/" && c === "/") {
          mode = LINE_COMMENT;
          return i;
        }
        if (c === "." && content.length) {
          while (determine_operator(content))
            ;
          mode = FLOAT;
          return i;
        }
        if (c === ";" || c === ")" || c === "(") {
          if (content.length)
            while (determine_operator(content))
              ;
          token(c);
          mode = NORMAL;
          return i + 1;
        }
        var is_composite_operator = content.length === 2 && c !== "=";
        if (/[\w_\d\s]/.test(c) || is_composite_operator) {
          while (determine_operator(content))
            ;
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function determine_operator(buf) {
        var j = 0, idx, res;
        do {
          idx = operators.indexOf(buf.slice(0, buf.length + j).join(""));
          res = operators[idx];
          if (idx === -1) {
            if (j-- + buf.length > 0)
              continue;
            res = buf.slice(0, 1).join("");
          }
          token(res);
          start += res.length;
          content = content.slice(res.length);
          return content.length;
        } while (1);
      }
      function hex() {
        if (/[^a-fA-F0-9]/.test(c)) {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function integer() {
        if (c === ".") {
          content.push(c);
          mode = FLOAT;
          last = c;
          return i + 1;
        }
        if (/[eE]/.test(c)) {
          content.push(c);
          mode = FLOAT;
          last = c;
          return i + 1;
        }
        if (c === "x" && content.length === 1 && content[0] === "0") {
          mode = HEX;
          content.push(c);
          last = c;
          return i + 1;
        }
        if (/[^\d]/.test(c)) {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function decimal() {
        if (c === "f") {
          content.push(c);
          last = c;
          i += 1;
        }
        if (/[eE]/.test(c)) {
          content.push(c);
          last = c;
          return i + 1;
        }
        if ((c === "-" || c === "+") && /[eE]/.test(last)) {
          content.push(c);
          last = c;
          return i + 1;
        }
        if (/[^\d]/.test(c)) {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function readtoken() {
        if (/[^\d\w_]/.test(c)) {
          var contentstr = content.join("");
          if (literalsDict[contentstr]) {
            mode = KEYWORD;
          } else if (builtinsDict[contentstr]) {
            mode = BUILTIN;
          } else {
            mode = IDENT;
          }
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
    }
  }
});

// node_modules/glsl-tokenizer/string.js
var require_string = __commonJS({
  "node_modules/glsl-tokenizer/string.js"(exports, module) {
    var tokenize = require_glsl_tokenizer();
    module.exports = tokenizeString;
    function tokenizeString(str, opt) {
      var generator = tokenize(opt);
      var tokens = [];
      tokens = tokens.concat(generator(str));
      tokens = tokens.concat(generator(null));
      return tokens;
    }
  }
});

// node_modules/atob-lite/atob-browser.js
var require_atob_browser = __commonJS({
  "node_modules/atob-lite/atob-browser.js"(exports, module) {
    module.exports = function _atob(str) {
      return atob(str);
    };
  }
});

// node_modules/glsl-shader-name/index.js
var require_glsl_shader_name = __commonJS({
  "node_modules/glsl-shader-name/index.js"(exports, module) {
    var tokenize = require_string();
    var atob2 = require_atob_browser();
    module.exports = getName;
    function getName(src) {
      var tokens = Array.isArray(src) ? src : tokenize(src);
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        if (token.type !== "preprocessor")
          continue;
        var match = token.data.match(/\#define\s+SHADER_NAME(_B64)?\s+(.+)$/);
        if (!match)
          continue;
        if (!match[2])
          continue;
        var b64 = match[1];
        var name2 = match[2];
        return (b64 ? atob2(name2) : name2).trim();
      }
    }
  }
});

// node_modules/repeat-string/index.js
var require_repeat_string = __commonJS({
  "node_modules/repeat-string/index.js"(exports, module) {
    "use strict";
    var res = "";
    var cache;
    module.exports = repeat;
    function repeat(str, num) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (num === 1)
        return str;
      if (num === 2)
        return str + str;
      var max = str.length * num;
      if (cache !== str || typeof cache === "undefined") {
        cache = str;
        res = "";
      } else if (res.length >= max) {
        return res.substr(0, max);
      }
      while (max > res.length && num > 1) {
        if (num & 1) {
          res += str;
        }
        num >>= 1;
        str += str;
      }
      res += str;
      res = res.substr(0, max);
      return res;
    }
  }
});

// node_modules/pad-left/index.js
var require_pad_left = __commonJS({
  "node_modules/pad-left/index.js"(exports, module) {
    "use strict";
    var repeat = require_repeat_string();
    module.exports = function padLeft(str, num, ch) {
      ch = typeof ch !== "undefined" ? ch + "" : " ";
      return repeat(ch, num) + str;
    };
  }
});

// node_modules/add-line-numbers/index.js
var require_add_line_numbers = __commonJS({
  "node_modules/add-line-numbers/index.js"(exports, module) {
    var padLeft = require_pad_left();
    module.exports = addLineNumbers;
    function addLineNumbers(string, start, delim) {
      start = typeof start === "number" ? start : 1;
      delim = delim || ": ";
      var lines = string.split(/\r?\n/);
      var totalDigits = String(lines.length + start - 1).length;
      return lines.map(function(line, i) {
        var c = i + start;
        var digits = String(c).length;
        var prefix = padLeft(c, totalDigits - digits);
        return prefix + delim + line;
      }).join("\n");
    }
  }
});

// node_modules/gl-format-compiler-error/index.js
var require_gl_format_compiler_error = __commonJS({
  "node_modules/gl-format-compiler-error/index.js"(exports, module) {
    var sprintf = require_sprintf().sprintf;
    var glConstants = require_lookup();
    var shaderName = require_glsl_shader_name();
    var addLineNumbers = require_add_line_numbers();
    module.exports = formatCompilerError;
    function formatCompilerError(errLog, src, type) {
      "use strict";
      var name2 = shaderName(src) || "of unknown name (see npm glsl-shader-name)";
      var typeName = "unknown type";
      if (type !== void 0) {
        typeName = type === glConstants.FRAGMENT_SHADER ? "fragment" : "vertex";
      }
      var longForm = sprintf("Error compiling %s shader %s:\n", typeName, name2);
      var shortForm = sprintf("%s%s", longForm, errLog);
      var errorStrings = errLog.split("\n");
      var errors = {};
      for (var i = 0; i < errorStrings.length; i++) {
        var errorString = errorStrings[i];
        if (errorString === "" || errorString === "\0")
          continue;
        var lineNo = parseInt(errorString.split(":")[2]);
        if (isNaN(lineNo)) {
          throw new Error(sprintf("Could not parse error: %s", errorString));
        }
        errors[lineNo] = errorString;
      }
      var lines = addLineNumbers(src).split("\n");
      for (var i = 0; i < lines.length; i++) {
        if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1])
          continue;
        var line = lines[i];
        longForm += line + "\n";
        if (errors[i + 1]) {
          var e = errors[i + 1];
          e = e.substr(e.split(":", 3).join(":").length + 1).trim();
          longForm += sprintf("^^^ %s\n\n", e);
        }
      }
      return {
        long: longForm.trim(),
        short: shortForm.trim()
      };
    }
  }
});

// node_modules/weakmap-shim/hidden-store.js
var require_hidden_store = __commonJS({
  "node_modules/weakmap-shim/hidden-store.js"(exports, module) {
    module.exports = hiddenStore;
    function hiddenStore(obj, key) {
      var store = { identity: key };
      var valueOf = obj.valueOf;
      Object.defineProperty(obj, "valueOf", {
        value: function(value) {
          return value !== key ? valueOf.apply(this, arguments) : store;
        },
        writable: true
      });
      return store;
    }
  }
});

// node_modules/weakmap-shim/create-store.js
var require_create_store = __commonJS({
  "node_modules/weakmap-shim/create-store.js"(exports, module) {
    var hiddenStore = require_hidden_store();
    module.exports = createStore;
    function createStore() {
      var key = {};
      return function(obj) {
        if ((typeof obj !== "object" || obj === null) && typeof obj !== "function") {
          throw new Error("Weakmap-shim: Key must be object");
        }
        var store = obj.valueOf(key);
        return store && store.identity === key ? store : hiddenStore(obj, key);
      };
    }
  }
});

// node_modules/weakmap-shim/index.js
var require_weakmap_shim = __commonJS({
  "node_modules/weakmap-shim/index.js"(exports, module) {
    var createStore = require_create_store();
    module.exports = weakMap;
    function weakMap() {
      var privates = createStore();
      return {
        "get": function(key, fallback) {
          var store = privates(key);
          return store.hasOwnProperty("value") ? store.value : fallback;
        },
        "set": function(key, value) {
          privates(key).value = value;
          return this;
        },
        "has": function(key) {
          return "value" in privates(key);
        },
        "delete": function(key) {
          return delete privates(key).value;
        }
      };
    }
  }
});

// node_modules/gl-shader/lib/shader-cache.js
var require_shader_cache = __commonJS({
  "node_modules/gl-shader/lib/shader-cache.js"(exports) {
    "use strict";
    exports.shader = getShaderReference;
    exports.program = createProgram;
    var GLError = require_GLError();
    var formatCompilerError = require_gl_format_compiler_error();
    var weakMap = typeof WeakMap === "undefined" ? require_weakmap_shim() : WeakMap;
    var CACHE = new weakMap();
    var SHADER_COUNTER = 0;
    function ShaderReference(id, src, type, shader, programs, count, cache) {
      this.id = id;
      this.src = src;
      this.type = type;
      this.shader = shader;
      this.count = count;
      this.programs = [];
      this.cache = cache;
    }
    ShaderReference.prototype.dispose = function() {
      if (--this.count === 0) {
        var cache = this.cache;
        var gl = cache.gl;
        var programs = this.programs;
        for (var i = 0, n = programs.length; i < n; ++i) {
          var p = cache.programs[programs[i]];
          if (p) {
            delete cache.programs[i];
            gl.deleteProgram(p);
          }
        }
        gl.deleteShader(this.shader);
        delete cache.shaders[this.type === gl.FRAGMENT_SHADER | 0][this.src];
      }
    };
    function ContextCache(gl) {
      this.gl = gl;
      this.shaders = [{}, {}];
      this.programs = {};
    }
    var proto = ContextCache.prototype;
    function compileShader(gl, type, src) {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        var errLog = gl.getShaderInfoLog(shader);
        try {
          var fmt = formatCompilerError(errLog, src, type);
        } catch (e) {
          console.warn("Failed to format compiler error: " + e);
          throw new GLError(errLog, "Error compiling shader:\n" + errLog);
        }
        throw new GLError(errLog, fmt.short, fmt.long);
      }
      return shader;
    }
    proto.getShaderReference = function(type, src) {
      var gl = this.gl;
      var shaders = this.shaders[type === gl.FRAGMENT_SHADER | 0];
      var shader = shaders[src];
      if (!shader || !gl.isShader(shader.shader)) {
        var shaderObj = compileShader(gl, type, src);
        shader = shaders[src] = new ShaderReference(
          SHADER_COUNTER++,
          src,
          type,
          shaderObj,
          [],
          1,
          this
        );
      } else {
        shader.count += 1;
      }
      return shader;
    };
    function linkProgram(gl, vshader, fshader, attribs, locations) {
      var program = gl.createProgram();
      gl.attachShader(program, vshader);
      gl.attachShader(program, fshader);
      for (var i = 0; i < attribs.length; ++i) {
        gl.bindAttribLocation(program, locations[i], attribs[i]);
      }
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        var errLog = gl.getProgramInfoLog(program);
        throw new GLError(errLog, "Error linking program: " + errLog);
      }
      return program;
    }
    proto.getProgram = function(vref, fref, attribs, locations) {
      var token = [vref.id, fref.id, attribs.join(":"), locations.join(":")].join("@");
      var prog = this.programs[token];
      if (!prog || !this.gl.isProgram(prog)) {
        this.programs[token] = prog = linkProgram(
          this.gl,
          vref.shader,
          fref.shader,
          attribs,
          locations
        );
        vref.programs.push(token);
        fref.programs.push(token);
      }
      return prog;
    };
    function getCache(gl) {
      var ctxCache = CACHE.get(gl);
      if (!ctxCache) {
        ctxCache = new ContextCache(gl);
        CACHE.set(gl, ctxCache);
      }
      return ctxCache;
    }
    function getShaderReference(gl, type, src) {
      return getCache(gl).getShaderReference(type, src);
    }
    function createProgram(gl, vref, fref, attribs, locations) {
      return getCache(gl).getProgram(vref, fref, attribs, locations);
    }
  }
});

// node_modules/gl-shader/lib/runtime-reflect.js
var require_runtime_reflect = __commonJS({
  "node_modules/gl-shader/lib/runtime-reflect.js"(exports) {
    "use strict";
    exports.uniforms = runtimeUniforms;
    exports.attributes = runtimeAttributes;
    var GL_TO_GLSL_TYPES = {
      "FLOAT": "float",
      "FLOAT_VEC2": "vec2",
      "FLOAT_VEC3": "vec3",
      "FLOAT_VEC4": "vec4",
      "INT": "int",
      "INT_VEC2": "ivec2",
      "INT_VEC3": "ivec3",
      "INT_VEC4": "ivec4",
      "BOOL": "bool",
      "BOOL_VEC2": "bvec2",
      "BOOL_VEC3": "bvec3",
      "BOOL_VEC4": "bvec4",
      "FLOAT_MAT2": "mat2",
      "FLOAT_MAT3": "mat3",
      "FLOAT_MAT4": "mat4",
      "SAMPLER_2D": "sampler2D",
      "SAMPLER_CUBE": "samplerCube"
    };
    var GL_TABLE = null;
    function getType(gl, type) {
      if (!GL_TABLE) {
        var typeNames = Object.keys(GL_TO_GLSL_TYPES);
        GL_TABLE = {};
        for (var i = 0; i < typeNames.length; ++i) {
          var tn = typeNames[i];
          GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
        }
      }
      return GL_TABLE[type];
    }
    function runtimeUniforms(gl, program) {
      var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
      var result = [];
      for (var i = 0; i < numUniforms; ++i) {
        var info = gl.getActiveUniform(program, i);
        if (info) {
          var type = getType(gl, info.type);
          if (info.size > 1) {
            for (var j = 0; j < info.size; ++j) {
              result.push({
                name: info.name.replace("[0]", "[" + j + "]"),
                type
              });
            }
          } else {
            result.push({
              name: info.name,
              type
            });
          }
        }
      }
      return result;
    }
    function runtimeAttributes(gl, program) {
      var numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
      var result = [];
      for (var i = 0; i < numAttributes; ++i) {
        var info = gl.getActiveAttrib(program, i);
        if (info) {
          result.push({
            name: info.name,
            type: getType(gl, info.type)
          });
        }
      }
      return result;
    }
  }
});

// node_modules/gl-shader/index.js
var require_gl_shader = __commonJS({
  "node_modules/gl-shader/index.js"(exports, module) {
    "use strict";
    var createUniformWrapper = require_create_uniforms();
    var createAttributeWrapper = require_create_attributes();
    var makeReflect = require_reflect();
    var shaderCache = require_shader_cache();
    var runtime = require_runtime_reflect();
    var GLError = require_GLError();
    function Shader(gl) {
      this.gl = gl;
      this.gl.lastAttribCount = 0;
      this._vref = this._fref = this._relink = this.vertShader = this.fragShader = this.program = this.attributes = this.uniforms = this.types = null;
    }
    var proto = Shader.prototype;
    proto.bind = function() {
      if (!this.program) {
        this._relink();
      }
      var i;
      var newAttribCount = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES);
      var oldAttribCount = this.gl.lastAttribCount;
      if (newAttribCount > oldAttribCount) {
        for (i = oldAttribCount; i < newAttribCount; i++) {
          this.gl.enableVertexAttribArray(i);
        }
      } else if (oldAttribCount > newAttribCount) {
        for (i = newAttribCount; i < oldAttribCount; i++) {
          this.gl.disableVertexAttribArray(i);
        }
      }
      this.gl.lastAttribCount = newAttribCount;
      this.gl.useProgram(this.program);
    };
    proto.dispose = function() {
      var oldAttribCount = this.gl.lastAttribCount;
      for (var i = 0; i < oldAttribCount; i++) {
        this.gl.disableVertexAttribArray(i);
      }
      this.gl.lastAttribCount = 0;
      if (this._fref) {
        this._fref.dispose();
      }
      if (this._vref) {
        this._vref.dispose();
      }
      this.attributes = this.types = this.vertShader = this.fragShader = this.program = this._relink = this._fref = this._vref = null;
    };
    function compareAttributes(a, b) {
      if (a.name < b.name) {
        return -1;
      }
      return 1;
    }
    proto.update = function(vertSource, fragSource, uniforms, attributes) {
      if (!fragSource || arguments.length === 1) {
        var obj = vertSource;
        vertSource = obj.vertex;
        fragSource = obj.fragment;
        uniforms = obj.uniforms;
        attributes = obj.attributes;
      }
      var wrapper = this;
      var gl = wrapper.gl;
      var pvref = wrapper._vref;
      wrapper._vref = shaderCache.shader(gl, gl.VERTEX_SHADER, vertSource);
      if (pvref) {
        pvref.dispose();
      }
      wrapper.vertShader = wrapper._vref.shader;
      var pfref = this._fref;
      wrapper._fref = shaderCache.shader(gl, gl.FRAGMENT_SHADER, fragSource);
      if (pfref) {
        pfref.dispose();
      }
      wrapper.fragShader = wrapper._fref.shader;
      if (!uniforms || !attributes) {
        var testProgram = gl.createProgram();
        gl.attachShader(testProgram, wrapper.fragShader);
        gl.attachShader(testProgram, wrapper.vertShader);
        gl.linkProgram(testProgram);
        if (!gl.getProgramParameter(testProgram, gl.LINK_STATUS)) {
          var errLog = gl.getProgramInfoLog(testProgram);
          throw new GLError(errLog, "Error linking program:" + errLog);
        }
        uniforms = uniforms || runtime.uniforms(gl, testProgram);
        attributes = attributes || runtime.attributes(gl, testProgram);
        gl.deleteProgram(testProgram);
      }
      attributes = attributes.slice();
      attributes.sort(compareAttributes);
      var attributeUnpacked = [];
      var attributeNames = [];
      var attributeLocations = [];
      var i;
      for (i = 0; i < attributes.length; ++i) {
        var attr = attributes[i];
        if (attr.type.indexOf("mat") >= 0) {
          var size = attr.type.charAt(attr.type.length - 1) | 0;
          var locVector = new Array(size);
          for (var j = 0; j < size; ++j) {
            locVector[j] = attributeLocations.length;
            attributeNames.push(attr.name + "[" + j + "]");
            if (typeof attr.location === "number") {
              attributeLocations.push(attr.location + j);
            } else if (Array.isArray(attr.location) && attr.location.length === size && typeof attr.location[j] === "number") {
              attributeLocations.push(attr.location[j] | 0);
            } else {
              attributeLocations.push(-1);
            }
          }
          attributeUnpacked.push({
            name: attr.name,
            type: attr.type,
            locations: locVector
          });
        } else {
          attributeUnpacked.push({
            name: attr.name,
            type: attr.type,
            locations: [attributeLocations.length]
          });
          attributeNames.push(attr.name);
          if (typeof attr.location === "number") {
            attributeLocations.push(attr.location | 0);
          } else {
            attributeLocations.push(-1);
          }
        }
      }
      var curLocation = 0;
      for (i = 0; i < attributeLocations.length; ++i) {
        if (attributeLocations[i] < 0) {
          while (attributeLocations.indexOf(curLocation) >= 0) {
            curLocation += 1;
          }
          attributeLocations[i] = curLocation;
        }
      }
      var uniformLocations = new Array(uniforms.length);
      function relink() {
        wrapper.program = shaderCache.program(
          gl,
          wrapper._vref,
          wrapper._fref,
          attributeNames,
          attributeLocations
        );
        for (var i2 = 0; i2 < uniforms.length; ++i2) {
          uniformLocations[i2] = gl.getUniformLocation(
            wrapper.program,
            uniforms[i2].name
          );
        }
      }
      relink();
      wrapper._relink = relink;
      wrapper.types = {
        uniforms: makeReflect(uniforms),
        attributes: makeReflect(attributes)
      };
      wrapper.attributes = createAttributeWrapper(
        gl,
        wrapper,
        attributeUnpacked,
        attributeLocations
      );
      Object.defineProperty(wrapper, "uniforms", createUniformWrapper(
        gl,
        wrapper,
        uniforms,
        uniformLocations
      ));
    };
    function createShader(gl, vertSource, fragSource, uniforms, attributes) {
      var shader = new Shader(gl);
      shader.update(
        vertSource,
        fragSource,
        uniforms,
        attributes
      );
      return shader;
    }
    module.exports = createShader;
  }
});

// node_modules/gl-react/lib/Visitors.js
var require_Visitors = __commonJS({
  "node_modules/gl-react/lib/Visitors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _globalVisitors = global.__glReactGlobalVisitor = global.__glReactGlobalVisitor || [];
    var Visitors = {
      /**
       * @memberof Visitors
       */
      add(visitor) {
        _globalVisitors.push(visitor);
      },
      /**
       * @memberof Visitors
       */
      remove(visitor) {
        const i = _globalVisitors.indexOf(visitor);
        if (i !== -1)
          _globalVisitors.splice(i, 1);
      },
      get() {
        return _globalVisitors;
      }
    };
    var _default = Visitors;
    exports.default = _default;
  }
});

// node_modules/webgltexture-loader/lib/WebGLTextureLoader.js
var require_WebGLTextureLoader = __commonJS({
  "node_modules/webgltexture-loader/lib/WebGLTextureLoader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var WebGLTextureLoader = class {
      /**
       * @property {WebGLRenderingContext} gl - the contextual rendering context
       */
      /**
       *
       */
      constructor(gl) {
        _defineProperty(this, "gl", void 0);
        this.gl = gl;
      }
      /**
       * Cancel and clear everything
       */
      dispose() {
      }
      /**
       * Check if the loader can handle a given input
       */
      canLoad(input) {
        return false;
      }
      /**
       * Load the resource by its input. returns a promise of {texture,width,height}.
       * idempotent: If load() is called twice with the same input, same promise is returned.
       */
      load(input) {
        return Promise.reject("load() is not implemented");
      }
      /**
       * try to get in sync the texture for a given input. otherwise null/undefined.
       * If null is returned, load() can be called in order to load the resource that will then be available in a future get() call.
       */
      get(input) {
        return null;
      }
      /**
       * sync the webgl texture with a loaded input. for instance for <video>/<canvas> elements this needs to be called recurrently (like in a requestAnimationFrame loop) to get the texture updated.
       * update should only get called IF get(input) was returning a result.
       */
      update(input) {
      }
    };
    exports.default = WebGLTextureLoader;
  }
});

// node_modules/webgltexture-loader/lib/WebGLTextureLoaderAsyncHashCache.js
var require_WebGLTextureLoaderAsyncHashCache = __commonJS({
  "node_modules/webgltexture-loader/lib/WebGLTextureLoaderAsyncHashCache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _WebGLTextureLoader = _interopRequireDefault(require_WebGLTextureLoader());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var neverEnding = new Promise(() => {
    });
    var WebGLTextureLoaderAsyncHashCache = class extends _WebGLTextureLoader.default {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "disposes", /* @__PURE__ */ new Map());
        _defineProperty(this, "inputs", /* @__PURE__ */ new Map());
        _defineProperty(this, "promises", /* @__PURE__ */ new Map());
        _defineProperty(this, "results", /* @__PURE__ */ new Map());
        _defineProperty(this, "_disposed", false);
      }
      inputHash(input) {
        return "";
      }
      // An async load function that does not cache (WebGLTextureLoaderAsyncHashCache do the caching with inputHash). it also should return a dispose function to cancel a pending load
      loadNoCache(input) {
        return {
          promise: Promise.reject(new Error("loadNoCache is not implemented")),
          dispose: () => {
          }
        };
      }
      dispose() {
        const {
          gl,
          promises,
          results,
          inputs,
          disposes
        } = this;
        disposes.forEach((d) => d());
        results.forEach((result) => {
          this.disposeTexture(result.texture);
        });
        promises.clear();
        results.clear();
        inputs.clear();
        disposes.clear();
        this._disposed = true;
      }
      disposeTexture(texture) {
        this.gl.deleteTexture(texture);
      }
      load(input) {
        const hash = this.inputHash(input);
        const maybePromise = this.promises.get(hash);
        if (maybePromise)
          return maybePromise;
        const d = this.loadNoCache(input);
        this.disposes.set(hash, d.dispose);
        const promise = d.promise.then((result) => {
          if (!this.promises.has(hash)) {
            return neverEnding;
          }
          this.disposes.delete(hash);
          this.results.set(hash, result);
          return result;
        });
        this.promises.set(hash, promise);
        return promise;
      }
      get(input) {
        return this.results.get(this.inputHash(input));
      }
      cancelLoad(input) {
        const hash = this.inputHash(input);
        this.promises.delete(hash);
        const dispose = this.disposes.get(hash);
        if (dispose) {
          dispose();
          this.disposes.delete(hash);
        }
      }
    };
    var _default = WebGLTextureLoaderAsyncHashCache;
    exports.default = _default;
  }
});

// node_modules/webgltexture-loader/lib/WebGLTextureLoaderSyncHashCache.js
var require_WebGLTextureLoaderSyncHashCache = __commonJS({
  "node_modules/webgltexture-loader/lib/WebGLTextureLoaderSyncHashCache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _WebGLTextureLoader = _interopRequireDefault(require_WebGLTextureLoader());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var WebGLTextureLoaderSyncHashCache = class extends _WebGLTextureLoader.default {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "results", /* @__PURE__ */ new Map());
        _defineProperty(this, "promises", /* @__PURE__ */ new Map());
        _defineProperty(this, "_disposed", false);
      }
      // return a unique representation of the input (typically a hash, or anything that can be used as ref identifier)
      inputHash(input) {
        return "";
      }
      // An async load function that does not cache (WebGLTextureLoaderAsyncHashCache do the caching with inputHash). it also should return a dispose function to cancel a pending load
      getNoCache(input) {
        throw new Error("getNoCache must be implemented");
      }
      dispose() {
        const {
          gl,
          results,
          promises
        } = this;
        results.forEach((r) => {
          this.disposeTexture(r.texture);
        });
        results.clear();
        promises.clear();
        this._disposed = true;
      }
      disposeTexture(texture) {
        this.gl.deleteTexture(texture);
      }
      get(input) {
        const hash = this.inputHash(input);
        const result = this.results.get(hash);
        if (result)
          return result;
        const freshResult = this.getNoCache(input);
        this.results.set(hash, freshResult);
        return freshResult;
      }
      // load() implementation is a dumb fallback on get() but still need to save the promise to guarantee idempotent
      load(input) {
        const hash = this.inputHash(input);
        const existing = this.promises.get(hash);
        if (existing)
          return existing;
        const promise = Promise.resolve(this.get(input));
        this.promises.set(hash, promise);
        return promise;
      }
    };
    var _default = WebGLTextureLoaderSyncHashCache;
    exports.default = _default;
  }
});

// node_modules/webgltexture-loader/lib/LoadersRegistry.js
var require_LoadersRegistry = __commonJS({
  "node_modules/webgltexture-loader/lib/LoadersRegistry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var LoadersRegistry = class {
      constructor() {
        _defineProperty(this, "_loaders", []);
      }
      /**
       * Add a TextureLoader class to extend texture format support.
       */
      add(loader) {
        this._loaders.push(loader);
        this._loaders.sort((a, b) => (
          // $FlowFixMe
          (typeof b.priority === "number" ? b.priority : 0) - // $FlowFixMe
          (typeof a.priority === "number" ? a.priority : 0)
        ));
      }
      /**
       * Remove a previously added WebGLTextureLoader class.
       */
      remove(loader) {
        const i = this._loaders.indexOf(loader);
        if (i !== -1) {
          this._loaders.splice(i, 1);
        }
      }
      /**
       * List the loaders ordered by most priority first
       */
      get() {
        return this._loaders;
      }
    };
    exports.default = LoadersRegistry;
  }
});

// node_modules/webgltexture-loader/lib/globalRegistry.js
var require_globalRegistry = __commonJS({
  "node_modules/webgltexture-loader/lib/globalRegistry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _LoadersRegistry = _interopRequireDefault(require_LoadersRegistry());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var root = typeof window === "undefined" ? global : window;
    var key = "__webglTextureLoader_registry";
    var _default = root[key] || (root[key] = new _LoadersRegistry.default());
    exports.default = _default;
  }
});

// node_modules/webgltexture-loader/lib/LoaderResolver.js
var require_LoaderResolver = __commonJS({
  "node_modules/webgltexture-loader/lib/LoaderResolver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _globalRegistry = _interopRequireDefault(require_globalRegistry());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var LoaderResolver = class {
      constructor(gl, registry = _globalRegistry.default) {
        _defineProperty(this, "loaders", void 0);
        this.loaders = registry.get().map((L) => new L(gl));
      }
      dispose() {
        this.loaders.forEach((l) => l.dispose());
      }
      resolve(input) {
        return this.loaders.find((loader) => loader.canLoad(input));
      }
    };
    exports.default = LoaderResolver;
  }
});

// node_modules/webgltexture-loader/lib/index.js
var require_lib = __commonJS({
  "node_modules/webgltexture-loader/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "WebGLTextureLoader", {
      enumerable: true,
      get: function() {
        return _WebGLTextureLoader.default;
      }
    });
    Object.defineProperty(exports, "WebGLTextureLoaderAsyncHashCache", {
      enumerable: true,
      get: function() {
        return _WebGLTextureLoaderAsyncHashCache.default;
      }
    });
    Object.defineProperty(exports, "WebGLTextureLoaderSyncHashCache", {
      enumerable: true,
      get: function() {
        return _WebGLTextureLoaderSyncHashCache.default;
      }
    });
    Object.defineProperty(exports, "LoadersRegistry", {
      enumerable: true,
      get: function() {
        return _LoadersRegistry.default;
      }
    });
    Object.defineProperty(exports, "LoaderResolver", {
      enumerable: true,
      get: function() {
        return _LoaderResolver.default;
      }
    });
    Object.defineProperty(exports, "globalRegistry", {
      enumerable: true,
      get: function() {
        return _globalRegistry.default;
      }
    });
    var _WebGLTextureLoader = _interopRequireDefault(require_WebGLTextureLoader());
    var _WebGLTextureLoaderAsyncHashCache = _interopRequireDefault(require_WebGLTextureLoaderAsyncHashCache());
    var _WebGLTextureLoaderSyncHashCache = _interopRequireDefault(require_WebGLTextureLoaderSyncHashCache());
    var _LoadersRegistry = _interopRequireDefault(require_LoadersRegistry());
    var _LoaderResolver = _interopRequireDefault(require_LoaderResolver());
    var _globalRegistry = _interopRequireDefault(require_globalRegistry());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// node_modules/gl-react/lib/createSurface.js
var require_createSurface = __commonJS({
  "node_modules/gl-react/lib/createSurface.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.list = exports.default = void 0;
    var _invariant = _interopRequireDefault(require_browser());
    var _react = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _glShader = _interopRequireDefault(require_gl_shader());
    var _Bus = _interopRequireDefault(require_Bus());
    var _Shaders = _interopRequireDefault(require_Shaders());
    var _Visitors = _interopRequireDefault(require_Visitors());
    var _webgltextureLoader = require_lib();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var __DEV__ = true;
    var SurfacePropTypes = {
      children: _propTypes.default.any.isRequired,
      style: _propTypes.default.any,
      preload: _propTypes.default.array,
      onLoad: _propTypes.default.func,
      onLoadError: _propTypes.default.func,
      onContextLost: _propTypes.default.func,
      onContextRestored: _propTypes.default.func,
      visitor: _propTypes.default.object
    };
    var surfaceId = 0;
    var _instances = [];
    var list = () => _instances.slice(0);
    exports.list = list;
    var allSurfaceProps = Object.keys(SurfacePropTypes);
    var _default = ({
      GLView,
      RenderLessElement,
      mapRenderableContent,
      requestFrame,
      cancelFrame
    }) => {
      var _class;
      return _class = class Surface extends _react.Component {
        constructor(...args) {
          super(...args);
          _defineProperty(this, "id", ++surfaceId);
          _defineProperty(this, "gl", void 0);
          _defineProperty(this, "buffer", void 0);
          _defineProperty(this, "loaderResolver", void 0);
          _defineProperty(this, "glView", void 0);
          _defineProperty(this, "root", void 0);
          _defineProperty(this, "shaders", {});
          _defineProperty(this, "_preparingGL", []);
          _defineProperty(this, "_needsRedraw", false);
          _defineProperty(this, "state", {
            ready: false,
            rebootId: 0,
            debug: false
          });
          _defineProperty(this, "RenderLessElement", RenderLessElement);
          _defineProperty(this, "mapRenderableContent", mapRenderableContent);
          _defineProperty(this, "redraw", () => {
            this._needsRedraw = true;
          });
          _defineProperty(this, "flush", () => {
            this._draw();
          });
          _defineProperty(this, "_emptyTexture", void 0);
          _defineProperty(this, "_onContextCreate", (gl) => {
            const onSuccess = () => {
              this.setState({
                ready: true
              }, () => {
                try {
                  this._handleLoad();
                } catch (e) {
                  this._handleError(e);
                }
              });
            };
            this._prepareGL(gl, onSuccess, this._handleError);
          });
          _defineProperty(this, "_onContextFailure", (e) => {
            this._handleError(e);
          });
          _defineProperty(this, "_onContextLost", () => {
            if (this.props.onContextLost)
              this.props.onContextLost();
            this._stopLoop();
            this._destroyGL();
            if (this.root)
              this.root._onContextLost();
          });
          _defineProperty(this, "_onContextRestored", (gl) => {
            if (this.root)
              this.root._onContextRestored(gl);
            this._prepareGL(gl, this._handleRestoredSuccess, this._handleRestoredFailure);
          });
          _defineProperty(this, "_onRef", (ref) => {
            this.glView = ref;
          });
          _defineProperty(this, "_handleError", (e) => {
            const {
              onLoadError
            } = this.props;
            if (onLoadError)
              onLoadError(e);
            else {
              console.error(e);
            }
          });
          _defineProperty(this, "_handleRestoredFailure", () => {
          });
          _defineProperty(this, "_handleRestoredSuccess", () => {
            this.redraw();
            this.flush();
            this._startLoop();
            if (this.props.onContextRestored)
              this.props.onContextRestored();
          });
          _defineProperty(this, "_handleLoad", () => {
            if (!this.root) {
              console.warn(this.getGLName() + " children does not contain any discoverable Node");
            }
            const {
              onLoad
            } = this.props;
            this.redraw();
            this.flush();
            this._startLoop();
            if (onLoad)
              onLoad();
          });
          _defineProperty(this, "_loopRaf", void 0);
        }
        getChildContext() {
          return {
            glParent: this,
            glSurface: this,
            glSizable: this
          };
        }
        componentDidMount() {
          _instances.push(this);
          this.getVisitors().forEach((v) => v.onSurfaceMount(this));
        }
        componentWillUnmount() {
          this._stopLoop();
          this._destroyGL();
          const i = _instances.indexOf(this);
          if (i !== -1)
            _instances.splice(i, 1);
          this.getVisitors().forEach((v) => v.onSurfaceUnmount(this));
        }
        componentDidUpdate() {
          this.redraw();
        }
        render() {
          const {
            props,
            state: {
              ready,
              rebootId,
              debug
            }
          } = this;
          const {
            children,
            style
          } = props;
          const rest = {};
          Object.keys(props).forEach((key) => {
            if (allSurfaceProps.indexOf(key) === -1) {
              rest[key] = props[key];
            }
          });
          return _react.default.createElement(GLView, _extends({
            key: rebootId,
            debug,
            ref: this._onRef,
            onContextCreate: this._onContextCreate,
            onContextFailure: this._onContextFailure,
            onContextLost: this._onContextLost,
            onContextRestored: this._onContextRestored,
            style
          }, rest), ready ? children : null);
        }
        rebootForDebug() {
          this._stopLoop();
          this._destroyGL();
          this.setState(({
            rebootId
          }) => ({
            rebootId: rebootId + 1,
            ready: false,
            debug: true
          }));
        }
        getVisitors() {
          return _Visitors.default.get().concat(this.props.visitor || []);
        }
        getGLSize() {
          const {
            gl
          } = this;
          return [gl ? gl.drawingBufferWidth : 0, gl ? gl.drawingBufferHeight : 0];
        }
        getGLName() {
          return `Surface#${this.id}`;
        }
        getGLShortName() {
          return "Surface";
        }
        /**
         * see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
         * @param {string} mimeType (optional) the image MimeType
         * @param {number} quality (optional) the image quality
         * @memberof Surface
         * @instance
         */
        captureAsDataURL(...args) {
          const {
            glView
          } = this;
          (0, _invariant.default)(glView, "GLView is mounted");
          (0, _invariant.default)(glView.captureAsDataURL, "captureAsDataURL is not defined in %s", GLView.displayName || GLView.name);
          return glView.captureAsDataURL(...args);
        }
        /**
         * see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob
         * @param {string} mimeType (optional) the image MimeType
         * @param {number} quality (optional) the image quality
         * @memberof Surface
         * @instance
         */
        captureAsBlob(...args) {
          const {
            glView
          } = this;
          (0, _invariant.default)(glView, "GLView is mounted");
          (0, _invariant.default)(glView.captureAsBlob, "captureAsBlob is not defined in %s", GLView.displayName || GLView.name);
          return glView.captureAsBlob(...args);
        }
        /**
         * capture the root Node pixels. Make sure you have set `preserveDrawingBuffer: true` in `webglContextAttributes` prop.
         * @memberof Surface
         * @instance
         */
        capture(x, y, w, h) {
          (0, _invariant.default)(this.root, "Surface#capture: surface is not yet ready or don't have any root Node");
          return this.root.capture(x, y, w, h);
        }
        /**
         * Schedule a redraw of the Surface.
         * @memberof Surface
         * @instance
         * @function
         */
        glIsAvailable() {
          return !!this.gl;
        }
        getEmptyTexture() {
          let {
            gl,
            _emptyTexture
          } = this;
          (0, _invariant.default)(gl, "getEmptyTexture called while gl was not defined");
          if (!_emptyTexture) {
            this._emptyTexture = _emptyTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, _emptyTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));
          }
          return _emptyTexture;
        }
        _destroyGL() {
          const {
            gl
          } = this;
          if (gl) {
            this.gl = null;
            if (this._emptyTexture) {
              gl.deleteTexture(this._emptyTexture);
              this._emptyTexture = null;
            }
            if (this.loaderResolver) {
              this.loaderResolver.dispose();
            }
            for (let k in this.shaders) {
              this.shaders[k].dispose();
            }
            this.shaders = {};
            gl.deleteBuffer(this.buffer);
            this.getVisitors().map((v) => v.onSurfaceGLContextChange(this, null));
          }
        }
        _prepareGL(gl, onSuccess, onError) {
          this.gl = gl;
          this.getVisitors().map((v) => v.onSurfaceGLContextChange(this, gl));
          this.loaderResolver = new _webgltextureLoader.LoaderResolver(gl);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
          const buffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array([-1, -1, -1, 4, 4, -1]),
            // see a-big-triangle
            gl.STATIC_DRAW
          );
          this.buffer = buffer;
          const {
            preload
          } = this.props;
          const all = [];
          (preload || []).forEach((raw) => {
            if (!raw) {
              console.warn("Can't preload value", raw);
              return;
            }
            const {
              loader,
              input
            } = this._resolveTextureLoader(raw);
            if (!loader) {
              console.warn("Can't preload input", raw, input);
              return;
            }
            const loadedAlready = loader.get(input);
            if (loadedAlready)
              return;
            all.push(loader.load(input));
          });
          this._preparingGL = all;
          if (all.length > 0) {
            Promise.all(all).then(onSuccess, onError);
          } else {
            onSuccess();
          }
        }
        _addGLNodeChild(node) {
          (0, _invariant.default)(!this.root, "Surface can only contains a single root. Got: %s", this.root && this.root.getGLName());
          this.root = node;
          node._addDependent(this);
          this.redraw();
        }
        _removeGLNodeChild(node) {
          this.root = null;
          this.redraw();
        }
        _resolveTextureLoader(raw) {
          let input = raw;
          let loader = this.loaderResolver && this.loaderResolver.resolve(input);
          return {
            loader,
            input
          };
        }
        _makeShader({
          frag,
          vert
        }, name2) {
          const {
            gl
          } = this;
          (0, _invariant.default)(gl, "gl is not available");
          const shader = (0, _glShader.default)(gl, vert, frag);
          for (let key in shader.attributes) {
            shader.attributes[key].pointer();
          }
          return shader;
        }
        _getShader(shaderId) {
          const {
            shaders
          } = this;
          return shaders[shaderId.id] || (shaders[shaderId.id] = this._makeShader(_Shaders.default.get(shaderId), _Shaders.default.getName(shaderId)));
        }
        _bindRootNode() {
          const {
            gl
          } = this;
          (0, _invariant.default)(gl, "gl context not available");
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          const [width, height] = this.getGLSize();
          gl.viewport(0, 0, width, height);
        }
        _startLoop() {
          cancelFrame(this._loopRaf);
          const loop = () => {
            this._loopRaf = requestFrame(loop);
            if (this._needsRedraw)
              this._draw();
          };
          this._loopRaf = requestFrame(loop);
        }
        _stopLoop() {
          cancelFrame(this._loopRaf);
        }
        _draw() {
          const {
            gl,
            root,
            glView
          } = this;
          (0, _invariant.default)(glView, "GLView is mounted");
          const visitors = this.getVisitors();
          if (!gl || !root || !this._needsRedraw) {
            visitors.forEach((v) => v.onSurfaceDrawSkipped(this));
            return;
          }
          this._needsRedraw = false;
          visitors.forEach((v) => v.onSurfaceDrawStart(this));
          if (glView.beforeDraw)
            glView.beforeDraw(gl);
          try {
            root._draw();
          } catch (e) {
            let silent = false;
            visitors.forEach((v) => {
              silent = v.onSurfaceDrawError(e) || silent;
            });
            if (!silent) {
              if (__DEV__ && glView.debugError && e.longMessage) {
                glView.debugError(e);
              } else {
                console.warn(e);
                throw e;
              }
            }
            return;
          }
          if (glView.afterDraw)
            glView.afterDraw(gl);
          visitors.forEach((v) => v.onSurfaceDrawEnd(this));
        }
      }, _defineProperty(_class, "propTypes", SurfacePropTypes), _defineProperty(_class, "childContextTypes", {
        glSurface: _propTypes.default.object.isRequired,
        glParent: _propTypes.default.object.isRequired,
        glSizable: _propTypes.default.object.isRequired
      }), _class;
    };
    exports.default = _default;
  }
});

// node_modules/gl-react/lib/copyShader.js
var require_copyShader = __commonJS({
  "node_modules/gl-react/lib/copyShader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _GLSL = _interopRequireDefault(require_GLSL());
    var _Shaders = _interopRequireDefault(require_Shaders());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _default = _Shaders.default.create({
      copy: {
        frag: (0, _GLSL.default)`
precision highp float;
varying vec2 uv;
uniform sampler2D t;
void main(){
  gl_FragColor=texture2D(t,uv);
}`
      }
    }).copy;
    exports.default = _default;
  }
});

// node_modules/gl-react/lib/LinearCopy.js
var require_LinearCopy = __commonJS({
  "node_modules/gl-react/lib/LinearCopy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _Node = _interopRequireDefault(require_Node());
    var _copyShader = _interopRequireDefault(require_copyShader());
    var _excluded = ["children"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var LinearCopy = class extends _react.Component {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "_node", void 0);
        _defineProperty(this, "_onRef", (node) => {
          this._node = node;
        });
      }
      /**
       * get a reference to the underlying Node instance
       * @return {Node}
       */
      getNodeRef() {
        return this._node;
      }
      render() {
        const _this$props = this.props, {
          children: t
        } = _this$props, rest = _objectWithoutProperties(_this$props, _excluded);
        return _react.default.createElement(_Node.default, _extends({}, rest, {
          ref: this._onRef,
          shader: _copyShader.default,
          blendFunc: {
            src: "one",
            dst: "one minus src alpha"
          },
          uniformsOptions: {
            t: {
              interpolation: "linear"
            }
          },
          uniforms: {
            t
          }
        }));
      }
    };
    var _default = LinearCopy;
    exports.default = _default;
  }
});

// node_modules/gl-react/lib/NearestCopy.js
var require_NearestCopy = __commonJS({
  "node_modules/gl-react/lib/NearestCopy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _Node = _interopRequireDefault(require_Node());
    var _copyShader = _interopRequireDefault(require_copyShader());
    var _excluded = ["children"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var NearestCopy = class extends _react.Component {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "_node", void 0);
        _defineProperty(this, "_onRef", (node) => {
          this._node = node;
        });
      }
      /**
       * get a reference to the underlying Node instance
       * @return {Node}
       */
      getNodeRef() {
        return this._node;
      }
      render() {
        const _this$props = this.props, {
          children: t
        } = _this$props, rest = _objectWithoutProperties(_this$props, _excluded);
        return _react.default.createElement(_Node.default, _extends({}, rest, {
          ref: this._onRef,
          shader: _copyShader.default,
          blendFunc: {
            src: "one",
            dst: "one minus src alpha"
          },
          uniformsOptions: {
            t: {
              interpolation: "nearest"
            }
          },
          uniforms: {
            t
          }
        }));
      }
    };
    var _default = NearestCopy;
    exports.default = _default;
  }
});

// node_modules/gl-react/lib/Visitor.js
var require_Visitor = __commonJS({
  "node_modules/gl-react/lib/Visitor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Visitor = class {
      /**
       *
       */
      onSurfaceMount(surface) {
      }
      /**
       *
       */
      onSurfaceUnmount(surface) {
      }
      /**
       *
       */
      onSurfaceGLContextChange(surface, gl) {
      }
      /**
       */
      onSurfaceDrawSkipped(surface) {
      }
      /**
       */
      onSurfaceDrawStart(surface) {
      }
      /**
       * if returns true, it prevent a throw to happen from the request animation frame loop (or from a surface.flush() call).
       */
      onSurfaceDrawError(e) {
        return false;
      }
      /**
       */
      onSurfaceDrawEnd(surface) {
      }
      /**
       */
      onNodeDrawSkipped(node) {
      }
      /**
       */
      onNodeDrawStart(node) {
      }
      /**
       */
      onNodeSyncDeps(node, additions, deletions) {
      }
      /**
       */
      onNodeDraw(node, preparedUniforms) {
      }
      /**
       */
      onNodeDrawEnd(node) {
      }
    };
    exports.default = Visitor;
  }
});

// node_modules/gl-react/lib/helpers/log.js
var require_log = __commonJS({
  "node_modules/gl-react/lib/helpers/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var {
      userAgent,
      vendor
    } = typeof navigator !== "undefined" ? navigator : {
      userAgent: "",
      vendor: ""
    };
    var exportedLog;
    var ffSupport;
    var formats;
    var getOrderedMatches;
    var hasMatches;
    var isFF;
    var isIE;
    var isOpera;
    var isSafari;
    var log;
    var operaSupport;
    var safariSupport;
    var stringToArgs;
    var _log;
    log = function(...args) {
      args.forEach(function(arg) {
        if (typeof arg === "string") {
          return args = args.concat(stringToArgs(arg));
        } else {
          return args.push(arg);
        }
      });
      return _log.apply(window, args);
    };
    _log = function(...args) {
      return Function.prototype.apply.call(console.log, console, args);
    };
    formats = [{
      regex: /\*([^\*]+)\*/,
      replacer: function(m, p1) {
        return "%c" + p1 + "%c";
      },
      styles: function() {
        return ["font-style: italic", ""];
      }
    }, {
      regex: /_([^_]+)_/,
      replacer: function(m, p1) {
        return "%c" + p1 + "%c";
      },
      styles: function() {
        return ["font-weight: bold", ""];
      }
    }, {
      regex: /`([^`]+)`/,
      replacer: function(m, p1) {
        return "%c" + p1 + "%c";
      },
      styles: function() {
        return ["background: rgb(255, 255, 219); padding: 1px 5px; border: 1px solid rgba(0, 0, 0, 0.1)", ""];
      }
    }, {
      regex: /\[c=(?:"|')?((?:(?!(?:"|')\]).)*)(?:"|')?\]((?:(?!\[c\]).)*)\[c\]/,
      replacer: function(m, p1, p2) {
        return "%c" + p2 + "%c";
      },
      styles: function(match) {
        return [match[1], ""];
      }
    }];
    hasMatches = function(str) {
      var _hasMatches;
      _hasMatches = false;
      formats.forEach(function(format) {
        if (format.regex.test(str)) {
          return _hasMatches = true;
        }
      });
      return _hasMatches;
    };
    getOrderedMatches = function(str) {
      var matches;
      matches = [];
      formats.forEach(function(format) {
        var match;
        match = str.match(format.regex);
        if (match) {
          return matches.push({
            format,
            match
          });
        }
      });
      return matches.sort(function(a, b) {
        return a.match.index - b.match.index;
      });
    };
    stringToArgs = function(str) {
      var firstMatch, matches, styles;
      styles = [];
      while (hasMatches(str)) {
        matches = getOrderedMatches(str);
        firstMatch = matches[0];
        str = str.replace(firstMatch.format.regex, firstMatch.format.replacer);
        styles = styles.concat(firstMatch.format.styles(firstMatch.match));
      }
      return [str].concat(styles);
    };
    isSafari = function() {
      return /Safari/.test(userAgent) && /Apple Computer/.test(vendor);
    };
    isOpera = function() {
      return /OPR/.test(userAgent) && /Opera/.test(vendor);
    };
    isFF = function() {
      return /Firefox/.test(userAgent);
    };
    isIE = function() {
      return /MSIE/.test(userAgent);
    };
    safariSupport = function() {
      var m;
      m = userAgent.match(/AppleWebKit\/(\d+)\.(\d+)(\.|\+|\s)/);
      if (!m) {
        return false;
      }
      return 537.38 <= parseInt(m[1], 10) + parseInt(m[2], 10) / 100;
    };
    operaSupport = function() {
      var m;
      m = userAgent.match(/OPR\/(\d+)\./);
      if (!m) {
        return false;
      }
      return 15 <= parseInt(m[1], 10);
    };
    ffSupport = function() {
      return typeof window !== "undefined" && (window.console.firebug || window.console.exception);
    };
    if (isIE() || isFF() && !ffSupport() || isOpera() && !operaSupport() || isSafari() && !safariSupport()) {
      exportedLog = _log;
    } else {
      exportedLog = log;
    }
    exportedLog.l = _log;
    var _default = exportedLog;
    exports.default = _default;
  }
});

// node_modules/gl-react/lib/VisitorLogger.js
var require_VisitorLogger = __commonJS({
  "node_modules/gl-react/lib/VisitorLogger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _log = _interopRequireDefault(require_log());
    var _Visitor = _interopRequireDefault(require_Visitor());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var aggregateInfo = (info) => Array.isArray(info) ? info.reduce((acc, info2) => acc.concat(aggregateInfo(info2)), []) : [String(info.dependency && info.dependency.getGLName() || info.initialObj)].concat(info.textureOptions ? [info.textureOptions] : []);
    var VisitorLogger = class extends _Visitor.default {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "groupNestedLvl", 0);
      }
      onSurfaceGLContextChange(surface, gl) {
        if (gl) {
          (0, _log.default)(surface.getGLName() + " _context acquired_");
        } else {
          (0, _log.default)(surface.getGLName() + " _context lost_");
        }
      }
      onSurfaceDrawSkipped() {
      }
      onSurfaceDrawStart(surface) {
        const [width, height] = surface.getGLSize();
        console.groupCollapsed("Surface draw");
        this.groupNestedLvl = 1;
        (0, _log.default)("_size_ `" + width + "`x`" + height + "`");
      }
      onSurfaceDrawError(e) {
        console.error(e);
        while (this.groupNestedLvl > 0) {
          console.groupEnd();
          this.groupNestedLvl--;
        }
        return true;
      }
      onSurfaceDrawEnd() {
        this.groupNestedLvl--;
        console.groupEnd();
      }
      onNodeDrawSkipped(node) {
        (0, _log.default)(node.getGLName() + " redraw _skipped_: " + (!node.context.glSurface.gl ? "no gl context available!" : !node._needsRedraw ? "no need to redraw" : ""));
      }
      onNodeDrawStart(node) {
        this.groupNestedLvl++;
        console.group(node.getGLName());
      }
      onNodeSyncDeps(node, additions, deletions) {
        if (additions.length)
          console.log(node.getGLName() + " +deps " + additions.map((n) => n.getGLName()).join(", "));
        if (deletions.length)
          console.log(node.getGLName() + " -deps " + additions.map((n) => n.getGLName()).join(", "));
      }
      onNodeDraw(node, preparedUniforms) {
        const {
          blendFunc,
          clear
        } = node.props;
        this.groupNestedLvl++;
        console.group("DRAW " + node.getGLName());
        const [w, h] = node.getGLSize();
        (0, _log.default)("_size_ `" + w + "`x`" + h + "` _clear_ `" + JSON.stringify(clear) + "` _blendFunc_ `" + JSON.stringify(blendFunc) + "`");
        (0, _log.default)("_" + preparedUniforms.length + " uniforms:_");
        preparedUniforms.forEach((obj) => {
          let {
            key,
            type,
            value,
            getMetaInfo
          } = obj;
          type = String(type || "UNKNOWN");
          const values = value === void 0 ? "" : Array.isArray(value) ? "[" + value.map((v) => "`" + String(v) + "`").join(",") + "]" : "`" + String(value) + "`";
          let spaces = "";
          for (let i = type.length + key.length - 18; i < 0; i++) {
            spaces += " ";
          }
          (0, _log.default)(`${spaces}*${type === "UNKNOWN" ? "[c='color:red']UNKNOWN[c]" : type}* _${key}_ = ${values}`, ...getMetaInfo ? aggregateInfo(getMetaInfo()) : []);
        });
      }
      onNodeDrawEnd() {
        this.groupNestedLvl -= 2;
        console.groupEnd();
        console.groupEnd();
      }
    };
    exports.default = VisitorLogger;
  }
});

// node_modules/uniq/uniq.js
var require_uniq = __commonJS({
  "node_modules/uniq/uniq.js"(exports, module) {
    "use strict";
    function unique_pred(list, compare) {
      var ptr = 1, len = list.length, a = list[0], b = list[0];
      for (var i = 1; i < len; ++i) {
        b = a;
        a = list[i];
        if (compare(a, b)) {
          if (i === ptr) {
            ptr++;
            continue;
          }
          list[ptr++] = a;
        }
      }
      list.length = ptr;
      return list;
    }
    function unique_eq(list) {
      var ptr = 1, len = list.length, a = list[0], b = list[0];
      for (var i = 1; i < len; ++i, b = a) {
        b = a;
        a = list[i];
        if (a !== b) {
          if (i === ptr) {
            ptr++;
            continue;
          }
          list[ptr++] = a;
        }
      }
      list.length = ptr;
      return list;
    }
    function unique(list, compare, sorted) {
      if (list.length === 0) {
        return list;
      }
      if (compare) {
        if (!sorted) {
          list.sort(compare);
        }
        return unique_pred(list, compare);
      }
      if (!sorted) {
        list.sort();
      }
      return unique_eq(list);
    }
    module.exports = unique;
  }
});

// node_modules/cwise-compiler/lib/compile.js
var require_compile = __commonJS({
  "node_modules/cwise-compiler/lib/compile.js"(exports, module) {
    "use strict";
    var uniq = require_uniq();
    function innerFill(order, proc, body) {
      var dimension = order.length, nargs = proc.arrayArgs.length, has_index = proc.indexArgs.length > 0, code = [], vars = [], idx = 0, pidx = 0, i, j;
      for (i = 0; i < dimension; ++i) {
        vars.push(["i", i, "=0"].join(""));
      }
      for (j = 0; j < nargs; ++j) {
        for (i = 0; i < dimension; ++i) {
          pidx = idx;
          idx = order[i];
          if (i === 0) {
            vars.push(["d", j, "s", i, "=t", j, "p", idx].join(""));
          } else {
            vars.push(["d", j, "s", i, "=(t", j, "p", idx, "-s", pidx, "*t", j, "p", pidx, ")"].join(""));
          }
        }
      }
      if (vars.length > 0) {
        code.push("var " + vars.join(","));
      }
      for (i = dimension - 1; i >= 0; --i) {
        idx = order[i];
        code.push(["for(i", i, "=0;i", i, "<s", idx, ";++i", i, "){"].join(""));
      }
      code.push(body);
      for (i = 0; i < dimension; ++i) {
        pidx = idx;
        idx = order[i];
        for (j = 0; j < nargs; ++j) {
          code.push(["p", j, "+=d", j, "s", i].join(""));
        }
        if (has_index) {
          if (i > 0) {
            code.push(["index[", pidx, "]-=s", pidx].join(""));
          }
          code.push(["++index[", idx, "]"].join(""));
        }
        code.push("}");
      }
      return code.join("\n");
    }
    function outerFill(matched, order, proc, body) {
      var dimension = order.length, nargs = proc.arrayArgs.length, blockSize = proc.blockSize, has_index = proc.indexArgs.length > 0, code = [];
      for (var i = 0; i < nargs; ++i) {
        code.push(["var offset", i, "=p", i].join(""));
      }
      for (var i = matched; i < dimension; ++i) {
        code.push(["for(var j" + i + "=SS[", order[i], "]|0;j", i, ">0;){"].join(""));
        code.push(["if(j", i, "<", blockSize, "){"].join(""));
        code.push(["s", order[i], "=j", i].join(""));
        code.push(["j", i, "=0"].join(""));
        code.push(["}else{s", order[i], "=", blockSize].join(""));
        code.push(["j", i, "-=", blockSize, "}"].join(""));
        if (has_index) {
          code.push(["index[", order[i], "]=j", i].join(""));
        }
      }
      for (var i = 0; i < nargs; ++i) {
        var indexStr = ["offset" + i];
        for (var j = matched; j < dimension; ++j) {
          indexStr.push(["j", j, "*t", i, "p", order[j]].join(""));
        }
        code.push(["p", i, "=(", indexStr.join("+"), ")"].join(""));
      }
      code.push(innerFill(order, proc, body));
      for (var i = matched; i < dimension; ++i) {
        code.push("}");
      }
      return code.join("\n");
    }
    function countMatches(orders) {
      var matched = 0, dimension = orders[0].length;
      while (matched < dimension) {
        for (var j = 1; j < orders.length; ++j) {
          if (orders[j][matched] !== orders[0][matched]) {
            return matched;
          }
        }
        ++matched;
      }
      return matched;
    }
    function processBlock(block, proc, dtypes) {
      var code = block.body;
      var pre = [];
      var post = [];
      for (var i = 0; i < block.args.length; ++i) {
        var carg = block.args[i];
        if (carg.count <= 0) {
          continue;
        }
        var re = new RegExp(carg.name, "g");
        var ptrStr = "";
        var arrNum = proc.arrayArgs.indexOf(i);
        switch (proc.argTypes[i]) {
          case "offset":
            var offArgIndex = proc.offsetArgIndex.indexOf(i);
            var offArg = proc.offsetArgs[offArgIndex];
            arrNum = offArg.array;
            ptrStr = "+q" + offArgIndex;
          case "array":
            ptrStr = "p" + arrNum + ptrStr;
            var localStr = "l" + i;
            var arrStr = "a" + arrNum;
            if (proc.arrayBlockIndices[arrNum] === 0) {
              if (carg.count === 1) {
                if (dtypes[arrNum] === "generic") {
                  if (carg.lvalue) {
                    pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""));
                    code = code.replace(re, localStr);
                    post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
                  } else {
                    code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""));
                  }
                } else {
                  code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
                }
              } else if (dtypes[arrNum] === "generic") {
                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""));
                code = code.replace(re, localStr);
                if (carg.lvalue) {
                  post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
                }
              } else {
                pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join(""));
                code = code.replace(re, localStr);
                if (carg.lvalue) {
                  post.push([arrStr, "[", ptrStr, "]=", localStr].join(""));
                }
              }
            } else {
              var reStrArr = [carg.name], ptrStrArr = [ptrStr];
              for (var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
                reStrArr.push("\\s*\\[([^\\]]+)\\]");
                ptrStrArr.push("$" + (j + 1) + "*t" + arrNum + "b" + j);
              }
              re = new RegExp(reStrArr.join(""), "g");
              ptrStr = ptrStrArr.join("+");
              if (dtypes[arrNum] === "generic") {
                throw new Error("cwise: Generic arrays not supported in combination with blocks!");
              } else {
                code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
              }
            }
            break;
          case "scalar":
            code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i));
            break;
          case "index":
            code = code.replace(re, "index");
            break;
          case "shape":
            code = code.replace(re, "shape");
            break;
        }
      }
      return [pre.join("\n"), code, post.join("\n")].join("\n").trim();
    }
    function typeSummary(dtypes) {
      var summary = new Array(dtypes.length);
      var allEqual = true;
      for (var i = 0; i < dtypes.length; ++i) {
        var t = dtypes[i];
        var digits = t.match(/\d+/);
        if (!digits) {
          digits = "";
        } else {
          digits = digits[0];
        }
        if (t.charAt(0) === 0) {
          summary[i] = "u" + t.charAt(1) + digits;
        } else {
          summary[i] = t.charAt(0) + digits;
        }
        if (i > 0) {
          allEqual = allEqual && summary[i] === summary[i - 1];
        }
      }
      if (allEqual) {
        return summary[0];
      }
      return summary.join("");
    }
    function generateCWiseOp(proc, typesig) {
      var dimension = typesig[1].length - Math.abs(proc.arrayBlockIndices[0]) | 0;
      var orders = new Array(proc.arrayArgs.length);
      var dtypes = new Array(proc.arrayArgs.length);
      for (var i = 0; i < proc.arrayArgs.length; ++i) {
        dtypes[i] = typesig[2 * i];
        orders[i] = typesig[2 * i + 1];
      }
      var blockBegin = [], blockEnd = [];
      var loopBegin = [], loopEnd = [];
      var loopOrders = [];
      for (var i = 0; i < proc.arrayArgs.length; ++i) {
        if (proc.arrayBlockIndices[i] < 0) {
          loopBegin.push(0);
          loopEnd.push(dimension);
          blockBegin.push(dimension);
          blockEnd.push(dimension + proc.arrayBlockIndices[i]);
        } else {
          loopBegin.push(proc.arrayBlockIndices[i]);
          loopEnd.push(proc.arrayBlockIndices[i] + dimension);
          blockBegin.push(0);
          blockEnd.push(proc.arrayBlockIndices[i]);
        }
        var newOrder = [];
        for (var j = 0; j < orders[i].length; j++) {
          if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) {
            newOrder.push(orders[i][j] - loopBegin[i]);
          }
        }
        loopOrders.push(newOrder);
      }
      var arglist = ["SS"];
      var code = ["'use strict'"];
      var vars = [];
      for (var j = 0; j < dimension; ++j) {
        vars.push(["s", j, "=SS[", j, "]"].join(""));
      }
      for (var i = 0; i < proc.arrayArgs.length; ++i) {
        arglist.push("a" + i);
        arglist.push("t" + i);
        arglist.push("p" + i);
        for (var j = 0; j < dimension; ++j) {
          vars.push(["t", i, "p", j, "=t", i, "[", loopBegin[i] + j, "]"].join(""));
        }
        for (var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j) {
          vars.push(["t", i, "b", j, "=t", i, "[", blockBegin[i] + j, "]"].join(""));
        }
      }
      for (var i = 0; i < proc.scalarArgs.length; ++i) {
        arglist.push("Y" + i);
      }
      if (proc.shapeArgs.length > 0) {
        vars.push("shape=SS.slice(0)");
      }
      if (proc.indexArgs.length > 0) {
        var zeros = new Array(dimension);
        for (var i = 0; i < dimension; ++i) {
          zeros[i] = "0";
        }
        vars.push(["index=[", zeros.join(","), "]"].join(""));
      }
      for (var i = 0; i < proc.offsetArgs.length; ++i) {
        var off_arg = proc.offsetArgs[i];
        var init_string = [];
        for (var j = 0; j < off_arg.offset.length; ++j) {
          if (off_arg.offset[j] === 0) {
            continue;
          } else if (off_arg.offset[j] === 1) {
            init_string.push(["t", off_arg.array, "p", j].join(""));
          } else {
            init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""));
          }
        }
        if (init_string.length === 0) {
          vars.push("q" + i + "=0");
        } else {
          vars.push(["q", i, "=", init_string.join("+")].join(""));
        }
      }
      var thisVars = uniq([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));
      vars = vars.concat(thisVars);
      if (vars.length > 0) {
        code.push("var " + vars.join(","));
      }
      for (var i = 0; i < proc.arrayArgs.length; ++i) {
        code.push("p" + i + "|=0");
      }
      if (proc.pre.body.length > 3) {
        code.push(processBlock(proc.pre, proc, dtypes));
      }
      var body = processBlock(proc.body, proc, dtypes);
      var matched = countMatches(loopOrders);
      if (matched < dimension) {
        code.push(outerFill(matched, loopOrders[0], proc, body));
      } else {
        code.push(innerFill(loopOrders[0], proc, body));
      }
      if (proc.post.body.length > 3) {
        code.push(processBlock(proc.post, proc, dtypes));
      }
      if (proc.debug) {
        console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------");
      }
      var loopName = [proc.funcName || "unnamed", "_cwise_loop_", orders[0].join("s"), "m", matched, typeSummary(dtypes)].join("");
      var f = new Function(["function ", loopName, "(", arglist.join(","), "){", code.join("\n"), "} return ", loopName].join(""));
      return f();
    }
    module.exports = generateCWiseOp;
  }
});

// node_modules/cwise-compiler/lib/thunk.js
var require_thunk = __commonJS({
  "node_modules/cwise-compiler/lib/thunk.js"(exports, module) {
    "use strict";
    var compile = require_compile();
    function createThunk(proc) {
      var code = ["'use strict'", "var CACHED={}"];
      var vars = [];
      var thunkName = proc.funcName + "_cwise_thunk";
      code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""));
      var typesig = [];
      var string_typesig = [];
      var proc_args = [[
        "array",
        proc.arrayArgs[0],
        ".shape.slice(",
        // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
        Math.max(0, proc.arrayBlockIndices[0]),
        proc.arrayBlockIndices[0] < 0 ? "," + proc.arrayBlockIndices[0] + ")" : ")"
      ].join("")];
      var shapeLengthConditions = [], shapeConditions = [];
      for (var i = 0; i < proc.arrayArgs.length; ++i) {
        var j = proc.arrayArgs[i];
        vars.push([
          "t",
          j,
          "=array",
          j,
          ".dtype,",
          "r",
          j,
          "=array",
          j,
          ".order"
        ].join(""));
        typesig.push("t" + j);
        typesig.push("r" + j);
        string_typesig.push("t" + j);
        string_typesig.push("r" + j + ".join()");
        proc_args.push("array" + j + ".data");
        proc_args.push("array" + j + ".stride");
        proc_args.push("array" + j + ".offset|0");
        if (i > 0) {
          shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));
          shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[i]) + "]");
        }
      }
      if (proc.arrayArgs.length > 1) {
        code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')");
        code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {");
        code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')");
        code.push("}");
      }
      for (var i = 0; i < proc.scalarArgs.length; ++i) {
        proc_args.push("scalar" + proc.scalarArgs[i]);
      }
      vars.push(["type=[", string_typesig.join(","), "].join()"].join(""));
      vars.push("proc=CACHED[type]");
      code.push("var " + vars.join(","));
      code.push([
        "if(!proc){",
        "CACHED[type]=proc=compile([",
        typesig.join(","),
        "])}",
        "return proc(",
        proc_args.join(","),
        ")}"
      ].join(""));
      if (proc.debug) {
        console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------");
      }
      var thunk = new Function("compile", code.join("\n"));
      return thunk(compile.bind(void 0, proc));
    }
    module.exports = createThunk;
  }
});

// node_modules/cwise-compiler/compiler.js
var require_compiler = __commonJS({
  "node_modules/cwise-compiler/compiler.js"(exports, module) {
    "use strict";
    var createThunk = require_thunk();
    function Procedure() {
      this.argTypes = [];
      this.shimArgs = [];
      this.arrayArgs = [];
      this.arrayBlockIndices = [];
      this.scalarArgs = [];
      this.offsetArgs = [];
      this.offsetArgIndex = [];
      this.indexArgs = [];
      this.shapeArgs = [];
      this.funcName = "";
      this.pre = null;
      this.body = null;
      this.post = null;
      this.debug = false;
    }
    function compileCwise(user_args) {
      var proc = new Procedure();
      proc.pre = user_args.pre;
      proc.body = user_args.body;
      proc.post = user_args.post;
      var proc_args = user_args.args.slice(0);
      proc.argTypes = proc_args;
      for (var i = 0; i < proc_args.length; ++i) {
        var arg_type = proc_args[i];
        if (arg_type === "array" || typeof arg_type === "object" && arg_type.blockIndices) {
          proc.argTypes[i] = "array";
          proc.arrayArgs.push(i);
          proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);
          proc.shimArgs.push("array" + i);
          if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
            throw new Error("cwise: pre() block may not reference array args");
          }
          if (i < proc.post.args.length && proc.post.args[i].count > 0) {
            throw new Error("cwise: post() block may not reference array args");
          }
        } else if (arg_type === "scalar") {
          proc.scalarArgs.push(i);
          proc.shimArgs.push("scalar" + i);
        } else if (arg_type === "index") {
          proc.indexArgs.push(i);
          if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
            throw new Error("cwise: pre() block may not reference array index");
          }
          if (i < proc.body.args.length && proc.body.args[i].lvalue) {
            throw new Error("cwise: body() block may not write to array index");
          }
          if (i < proc.post.args.length && proc.post.args[i].count > 0) {
            throw new Error("cwise: post() block may not reference array index");
          }
        } else if (arg_type === "shape") {
          proc.shapeArgs.push(i);
          if (i < proc.pre.args.length && proc.pre.args[i].lvalue) {
            throw new Error("cwise: pre() block may not write to array shape");
          }
          if (i < proc.body.args.length && proc.body.args[i].lvalue) {
            throw new Error("cwise: body() block may not write to array shape");
          }
          if (i < proc.post.args.length && proc.post.args[i].lvalue) {
            throw new Error("cwise: post() block may not write to array shape");
          }
        } else if (typeof arg_type === "object" && arg_type.offset) {
          proc.argTypes[i] = "offset";
          proc.offsetArgs.push({ array: arg_type.array, offset: arg_type.offset });
          proc.offsetArgIndex.push(i);
        } else {
          throw new Error("cwise: Unknown argument type " + proc_args[i]);
        }
      }
      if (proc.arrayArgs.length <= 0) {
        throw new Error("cwise: No array arguments specified");
      }
      if (proc.pre.args.length > proc_args.length) {
        throw new Error("cwise: Too many arguments in pre() block");
      }
      if (proc.body.args.length > proc_args.length) {
        throw new Error("cwise: Too many arguments in body() block");
      }
      if (proc.post.args.length > proc_args.length) {
        throw new Error("cwise: Too many arguments in post() block");
      }
      proc.debug = !!user_args.printCode || !!user_args.debug;
      proc.funcName = user_args.funcName || "cwise";
      proc.blockSize = user_args.blockSize || 64;
      return createThunk(proc);
    }
    module.exports = compileCwise;
  }
});

// node_modules/ndarray-ops/ndarray-ops.js
var require_ndarray_ops = __commonJS({
  "node_modules/ndarray-ops/ndarray-ops.js"(exports) {
    "use strict";
    var compile = require_compiler();
    var EmptyProc = {
      body: "",
      args: [],
      thisVars: [],
      localVars: []
    };
    function fixup(x) {
      if (!x) {
        return EmptyProc;
      }
      for (var i = 0; i < x.args.length; ++i) {
        var a = x.args[i];
        if (i === 0) {
          x.args[i] = { name: a, lvalue: true, rvalue: !!x.rvalue, count: x.count || 1 };
        } else {
          x.args[i] = { name: a, lvalue: false, rvalue: true, count: 1 };
        }
      }
      if (!x.thisVars) {
        x.thisVars = [];
      }
      if (!x.localVars) {
        x.localVars = [];
      }
      return x;
    }
    function pcompile(user_args) {
      return compile({
        args: user_args.args,
        pre: fixup(user_args.pre),
        body: fixup(user_args.body),
        post: fixup(user_args.proc),
        funcName: user_args.funcName
      });
    }
    function makeOp(user_args) {
      var args = [];
      for (var i = 0; i < user_args.args.length; ++i) {
        args.push("a" + i);
      }
      var wrapper = new Function("P", [
        "return function ",
        user_args.funcName,
        "_ndarrayops(",
        args.join(","),
        ") {P(",
        args.join(","),
        ");return a0}"
      ].join(""));
      return wrapper(pcompile(user_args));
    }
    var assign_ops = {
      add: "+",
      sub: "-",
      mul: "*",
      div: "/",
      mod: "%",
      band: "&",
      bor: "|",
      bxor: "^",
      lshift: "<<",
      rshift: ">>",
      rrshift: ">>>"
    };
    (function() {
      for (var id in assign_ops) {
        var op = assign_ops[id];
        exports[id] = makeOp({
          args: ["array", "array", "array"],
          body: {
            args: ["a", "b", "c"],
            body: "a=b" + op + "c"
          },
          funcName: id
        });
        exports[id + "eq"] = makeOp({
          args: ["array", "array"],
          body: {
            args: ["a", "b"],
            body: "a" + op + "=b"
          },
          rvalue: true,
          funcName: id + "eq"
        });
        exports[id + "s"] = makeOp({
          args: ["array", "array", "scalar"],
          body: {
            args: ["a", "b", "s"],
            body: "a=b" + op + "s"
          },
          funcName: id + "s"
        });
        exports[id + "seq"] = makeOp({
          args: ["array", "scalar"],
          body: {
            args: ["a", "s"],
            body: "a" + op + "=s"
          },
          rvalue: true,
          funcName: id + "seq"
        });
      }
    })();
    var unary_ops = {
      not: "!",
      bnot: "~",
      neg: "-",
      recip: "1.0/"
    };
    (function() {
      for (var id in unary_ops) {
        var op = unary_ops[id];
        exports[id] = makeOp({
          args: ["array", "array"],
          body: {
            args: ["a", "b"],
            body: "a=" + op + "b"
          },
          funcName: id
        });
        exports[id + "eq"] = makeOp({
          args: ["array"],
          body: {
            args: ["a"],
            body: "a=" + op + "a"
          },
          rvalue: true,
          count: 2,
          funcName: id + "eq"
        });
      }
    })();
    var binary_ops = {
      and: "&&",
      or: "||",
      eq: "===",
      neq: "!==",
      lt: "<",
      gt: ">",
      leq: "<=",
      geq: ">="
    };
    (function() {
      for (var id in binary_ops) {
        var op = binary_ops[id];
        exports[id] = makeOp({
          args: ["array", "array", "array"],
          body: {
            args: ["a", "b", "c"],
            body: "a=b" + op + "c"
          },
          funcName: id
        });
        exports[id + "s"] = makeOp({
          args: ["array", "array", "scalar"],
          body: {
            args: ["a", "b", "s"],
            body: "a=b" + op + "s"
          },
          funcName: id + "s"
        });
        exports[id + "eq"] = makeOp({
          args: ["array", "array"],
          body: {
            args: ["a", "b"],
            body: "a=a" + op + "b"
          },
          rvalue: true,
          count: 2,
          funcName: id + "eq"
        });
        exports[id + "seq"] = makeOp({
          args: ["array", "scalar"],
          body: {
            args: ["a", "s"],
            body: "a=a" + op + "s"
          },
          rvalue: true,
          count: 2,
          funcName: id + "seq"
        });
      }
    })();
    var math_unary = [
      "abs",
      "acos",
      "asin",
      "atan",
      "ceil",
      "cos",
      "exp",
      "floor",
      "log",
      "round",
      "sin",
      "sqrt",
      "tan"
    ];
    (function() {
      for (var i = 0; i < math_unary.length; ++i) {
        var f = math_unary[i];
        exports[f] = makeOp({
          args: ["array", "array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(b)", thisVars: ["this_f"] },
          funcName: f
        });
        exports[f + "eq"] = makeOp({
          args: ["array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a"], body: "a=this_f(a)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: f + "eq"
        });
      }
    })();
    var math_comm = [
      "max",
      "min",
      "atan2",
      "pow"
    ];
    (function() {
      for (var i = 0; i < math_comm.length; ++i) {
        var f = math_comm[i];
        exports[f] = makeOp({
          args: ["array", "array", "array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b", "c"], body: "a=this_f(b,c)", thisVars: ["this_f"] },
          funcName: f
        });
        exports[f + "s"] = makeOp({
          args: ["array", "array", "scalar"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b", "c"], body: "a=this_f(b,c)", thisVars: ["this_f"] },
          funcName: f + "s"
        });
        exports[f + "eq"] = makeOp({
          args: ["array", "array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(a,b)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: f + "eq"
        });
        exports[f + "seq"] = makeOp({
          args: ["array", "scalar"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(a,b)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: f + "seq"
        });
      }
    })();
    var math_noncomm = [
      "atan2",
      "pow"
    ];
    (function() {
      for (var i = 0; i < math_noncomm.length; ++i) {
        var f = math_noncomm[i];
        exports[f + "op"] = makeOp({
          args: ["array", "array", "array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b", "c"], body: "a=this_f(c,b)", thisVars: ["this_f"] },
          funcName: f + "op"
        });
        exports[f + "ops"] = makeOp({
          args: ["array", "array", "scalar"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b", "c"], body: "a=this_f(c,b)", thisVars: ["this_f"] },
          funcName: f + "ops"
        });
        exports[f + "opeq"] = makeOp({
          args: ["array", "array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(b,a)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: f + "opeq"
        });
        exports[f + "opseq"] = makeOp({
          args: ["array", "scalar"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(b,a)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: f + "opseq"
        });
      }
    })();
    exports.any = compile({
      args: ["array"],
      pre: EmptyProc,
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 1 }], body: "if(a){return true}", localVars: [], thisVars: [] },
      post: { args: [], localVars: [], thisVars: [], body: "return false" },
      funcName: "any"
    });
    exports.all = compile({
      args: ["array"],
      pre: EmptyProc,
      body: { args: [{ name: "x", lvalue: false, rvalue: true, count: 1 }], body: "if(!x){return false}", localVars: [], thisVars: [] },
      post: { args: [], localVars: [], thisVars: [], body: "return true" },
      funcName: "all"
    });
    exports.sum = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 1 }], body: "this_s+=a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "sum"
    });
    exports.prod = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=1" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 1 }], body: "this_s*=a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "prod"
    });
    exports.norm2squared = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 2 }], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "norm2squared"
    });
    exports.norm2 = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 2 }], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return Math.sqrt(this_s)" },
      funcName: "norm2"
    });
    exports.norminf = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 4 }], body: "if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "norminf"
    });
    exports.norm1 = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 3 }], body: "this_s+=a<0?-a:a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "norm1"
    });
    exports.sup = compile({
      args: ["array"],
      pre: {
        body: "this_h=-Infinity",
        args: [],
        thisVars: ["this_h"],
        localVars: []
      },
      body: {
        body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
        args: [{ "name": "_inline_1_arg0_", "lvalue": false, "rvalue": true, "count": 2 }],
        thisVars: ["this_h"],
        localVars: []
      },
      post: {
        body: "return this_h",
        args: [],
        thisVars: ["this_h"],
        localVars: []
      }
    });
    exports.inf = compile({
      args: ["array"],
      pre: {
        body: "this_h=Infinity",
        args: [],
        thisVars: ["this_h"],
        localVars: []
      },
      body: {
        body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
        args: [{ "name": "_inline_1_arg0_", "lvalue": false, "rvalue": true, "count": 2 }],
        thisVars: ["this_h"],
        localVars: []
      },
      post: {
        body: "return this_h",
        args: [],
        thisVars: ["this_h"],
        localVars: []
      }
    });
    exports.argmin = compile({
      args: ["index", "array", "shape"],
      pre: {
        body: "{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
        args: [
          { name: "_inline_0_arg0_", lvalue: false, rvalue: false, count: 0 },
          { name: "_inline_0_arg1_", lvalue: false, rvalue: false, count: 0 },
          { name: "_inline_0_arg2_", lvalue: false, rvalue: true, count: 1 }
        ],
        thisVars: ["this_i", "this_v"],
        localVars: []
      },
      body: {
        body: "{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
        args: [
          { name: "_inline_1_arg0_", lvalue: false, rvalue: true, count: 2 },
          { name: "_inline_1_arg1_", lvalue: false, rvalue: true, count: 2 }
        ],
        thisVars: ["this_i", "this_v"],
        localVars: ["_inline_1_k"]
      },
      post: {
        body: "{return this_i}",
        args: [],
        thisVars: ["this_i"],
        localVars: []
      }
    });
    exports.argmax = compile({
      args: ["index", "array", "shape"],
      pre: {
        body: "{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
        args: [
          { name: "_inline_0_arg0_", lvalue: false, rvalue: false, count: 0 },
          { name: "_inline_0_arg1_", lvalue: false, rvalue: false, count: 0 },
          { name: "_inline_0_arg2_", lvalue: false, rvalue: true, count: 1 }
        ],
        thisVars: ["this_i", "this_v"],
        localVars: []
      },
      body: {
        body: "{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
        args: [
          { name: "_inline_1_arg0_", lvalue: false, rvalue: true, count: 2 },
          { name: "_inline_1_arg1_", lvalue: false, rvalue: true, count: 2 }
        ],
        thisVars: ["this_i", "this_v"],
        localVars: ["_inline_1_k"]
      },
      post: {
        body: "{return this_i}",
        args: [],
        thisVars: ["this_i"],
        localVars: []
      }
    });
    exports.random = makeOp({
      args: ["array"],
      pre: { args: [], body: "this_f=Math.random", thisVars: ["this_f"] },
      body: { args: ["a"], body: "a=this_f()", thisVars: ["this_f"] },
      funcName: "random"
    });
    exports.assign = makeOp({
      args: ["array", "array"],
      body: { args: ["a", "b"], body: "a=b" },
      funcName: "assign"
    });
    exports.assigns = makeOp({
      args: ["array", "scalar"],
      body: { args: ["a", "b"], body: "a=b" },
      funcName: "assigns"
    });
    exports.equals = compile({
      args: ["array", "array"],
      pre: EmptyProc,
      body: {
        args: [
          { name: "x", lvalue: false, rvalue: true, count: 1 },
          { name: "y", lvalue: false, rvalue: true, count: 1 }
        ],
        body: "if(x!==y){return false}",
        localVars: [],
        thisVars: []
      },
      post: { args: [], localVars: [], thisVars: [], body: "return true" },
      funcName: "equals"
    });
  }
});

// node_modules/webgltexture-loader-ndarray/lib/drawNDArrayTexture.js
var require_drawNDArrayTexture = __commonJS({
  "node_modules/webgltexture-loader-ndarray/lib/drawNDArrayTexture.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _ndarray = _interopRequireDefault(require_ndarray());
    var _ndarrayOps = _interopRequireDefault(require_ndarray_ops());
    var _typedarrayPool = _interopRequireDefault(require_pool());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    if (typeof Buffer === "undefined") {
      global.Buffer = (_class = class Buffer {
      }, _defineProperty(_class, "isBuffer", (b) => b instanceof _class), _class);
    }
    var _class;
    function isPacked(shape, stride) {
      if (shape.length === 3) {
        return stride[2] === 1 && stride[1] === shape[0] * shape[2] && stride[0] === shape[2];
      }
      return stride[0] === 1 && stride[1] === shape[0];
    }
    function convertFloatToUint8(out, inp) {
      _ndarrayOps.default.muls(out, inp, 255);
    }
    var _default = (gl, texture, array, floatSupported) => {
      const isWebGL1 = typeof WebGLRenderingContext === "undefined" || gl instanceof WebGLRenderingContext;
      let dtype = array.dtype;
      let shape = array.shape.slice();
      let maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      if (shape[0] < 0 || shape[0] > maxSize || shape[1] < 0 || shape[1] > maxSize) {
        throw new Error("gl-react: Invalid texture size");
      }
      let packed = isPacked(shape, array.stride.slice());
      let type = 0;
      if (dtype === "float32") {
        type = gl.FLOAT;
      } else if (dtype === "float64") {
        type = gl.FLOAT;
        packed = false;
        dtype = "float32";
      } else if (dtype === "uint8") {
        type = gl.UNSIGNED_BYTE;
      } else {
        type = gl.UNSIGNED_BYTE;
        packed = false;
        dtype = "uint8";
      }
      let format = 0;
      let internalformat = 0;
      if (shape.length === 2) {
        internalformat = format = gl.LUMINANCE;
        shape = [shape[0], shape[1], 1];
        array = (0, _ndarray.default)(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset);
      } else if (shape.length === 3) {
        if (shape[2] === 1) {
          internalformat = format = gl.ALPHA;
          if (!isWebGL1) {
            floatSupported = false;
          }
        } else if (shape[2] === 2) {
          internalformat = format = gl.LUMINANCE_ALPHA;
          if (!isWebGL1) {
            floatSupported = false;
          }
        } else if (shape[2] === 3) {
          format = gl.RGB;
          internalformat = isWebGL1 ? gl.RGB : gl.RGB32F;
        } else if (shape[2] === 4) {
          format = gl.RGBA;
          internalformat = isWebGL1 ? gl.RGBA : gl.RGBA32F;
        } else {
          throw new Error("gl-texture2d: Invalid shape for pixel coords");
        }
      } else {
        throw new Error("gl-texture2d: Invalid shape for texture");
      }
      if (type === gl.FLOAT && !floatSupported) {
        type = gl.UNSIGNED_BYTE;
        packed = false;
      }
      let buffer;
      let size = array.size;
      let store;
      if (!packed) {
        let stride = [shape[2], shape[2] * shape[0], 1];
        if ((dtype === "float32" || dtype === "float64") && type === gl.UNSIGNED_BYTE) {
          store = _typedarrayPool.default.malloc(size, "uint8");
          let out = (0, _ndarray.default)(store, shape, stride, 0);
          convertFloatToUint8(out, array);
        } else {
          store = _typedarrayPool.default.malloc(size, dtype);
          let out = (0, _ndarray.default)(store, shape, stride, 0);
          _ndarrayOps.default.assign(out, array);
        }
        buffer = store.subarray(0, size);
      } else if (array.offset === 0 && array.data.length === size) {
        buffer = array.data;
      } else {
        buffer = array.data.subarray(array.offset, array.offset + size);
      }
      gl.texImage2D(gl.TEXTURE_2D, 0, internalformat, shape[0], shape[1], 0, format, type, buffer);
      if (store) {
        _typedarrayPool.default.free(store);
      }
    };
    exports.default = _default;
  }
});

// node_modules/webgltexture-loader-ndarray/lib/NDArrayTextureLoader.js
var require_NDArrayTextureLoader = __commonJS({
  "node_modules/webgltexture-loader-ndarray/lib/NDArrayTextureLoader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _webgltextureLoader = require_lib();
    var _drawNDArrayTexture = _interopRequireDefault(require_drawNDArrayTexture());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var NDArrayTextureLoader = class extends _webgltextureLoader.WebGLTextureLoaderSyncHashCache {
      constructor(gl) {
        super(gl);
        _defineProperty(this, "floatSupported", void 0);
        this.floatSupported = gl.getExtension("OES_texture_float_linear");
      }
      canLoad(obj) {
        return obj.shape && obj.data && obj.stride;
      }
      inputHash(input) {
        return input;
      }
      getNoCache(input) {
        const {
          gl
        } = this;
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        const [width, height] = input.shape;
        (0, _drawNDArrayTexture.default)(gl, texture, input, this.floatSupported);
        return {
          texture,
          width,
          height
        };
      }
      update(input) {
        const {
          gl
        } = this;
        const {
          texture
        } = this.get(input);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        (0, _drawNDArrayTexture.default)(gl, texture, input, this.floatSupported);
      }
    };
    _webgltextureLoader.globalRegistry.add(NDArrayTextureLoader);
    var _default = NDArrayTextureLoader;
    exports.default = _default;
  }
});

// node_modules/gl-react/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/gl-react/lib/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Backbuffer = void 0;
    Object.defineProperty(exports, "Bus", {
      enumerable: true,
      get: function() {
        return _Bus.default;
      }
    });
    Object.defineProperty(exports, "GLSL", {
      enumerable: true,
      get: function() {
        return _GLSL.default;
      }
    });
    Object.defineProperty(exports, "LinearCopy", {
      enumerable: true,
      get: function() {
        return _LinearCopy.default;
      }
    });
    Object.defineProperty(exports, "NearestCopy", {
      enumerable: true,
      get: function() {
        return _NearestCopy.default;
      }
    });
    Object.defineProperty(exports, "Node", {
      enumerable: true,
      get: function() {
        return _Node.default;
      }
    });
    Object.defineProperty(exports, "Shaders", {
      enumerable: true,
      get: function() {
        return _Shaders.default;
      }
    });
    Object.defineProperty(exports, "Uniform", {
      enumerable: true,
      get: function() {
        return _Uniform.default;
      }
    });
    Object.defineProperty(exports, "Visitor", {
      enumerable: true,
      get: function() {
        return _Visitor.default;
      }
    });
    Object.defineProperty(exports, "VisitorLogger", {
      enumerable: true,
      get: function() {
        return _VisitorLogger.default;
      }
    });
    Object.defineProperty(exports, "Visitors", {
      enumerable: true,
      get: function() {
        return _Visitors.default;
      }
    });
    Object.defineProperty(exports, "connectSize", {
      enumerable: true,
      get: function() {
        return _connectSize.default;
      }
    });
    Object.defineProperty(exports, "createSurface", {
      enumerable: true,
      get: function() {
        return _createSurface.default;
      }
    });
    Object.defineProperty(exports, "listSurfaces", {
      enumerable: true,
      get: function() {
        return _createSurface.list;
      }
    });
    var _Bus = _interopRequireDefault(require_Bus());
    var _connectSize = _interopRequireDefault(require_connectSize());
    var _createSurface = _interopRequireWildcard(require_createSurface());
    var _GLSL = _interopRequireDefault(require_GLSL());
    var _LinearCopy = _interopRequireDefault(require_LinearCopy());
    var _NearestCopy = _interopRequireDefault(require_NearestCopy());
    var _Node = _interopRequireDefault(require_Node());
    var _Shaders = _interopRequireDefault(require_Shaders());
    var _Uniform = _interopRequireDefault(require_Uniform());
    var _Visitor = _interopRequireDefault(require_Visitor());
    var _VisitorLogger = _interopRequireDefault(require_VisitorLogger());
    var _Visitors = _interopRequireDefault(require_Visitors());
    require_NDArrayTextureLoader();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Backbuffer = "Backbuffer";
    exports.Backbuffer = Backbuffer;
  }
});

export {
  require_browser,
  require_prop_types,
  require_lib,
  require_lib2
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

repeat-string/index.js:
  (*!
   * repeat-string <https://github.com/jonschlinkert/repeat-string>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

pad-left/index.js:
  (*!
   * pad-left <https://github.com/jonschlinkert/pad-left>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT license.
   *)
*/
//# sourceMappingURL=chunk-JHWA62D5.js.map
